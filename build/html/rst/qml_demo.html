<!DOCTYPE html>
<html class="writer-html5" lang="en-English" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quantum Machine Learning Demos &mdash; VQNET v0.13 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="QTensor Module" href="QTensor.html" />
    <link rel="prev" title="Steps of VQNet Installation" href="install.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> VQNET
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Installation Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Steps of VQNet Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Hand by hand tutorial</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quantum Machine Learning Demos</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#application-of-parameterized-quantum-circuit-in-classification-task">Application of Parameterized Quantum Circuit in Classification Task</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#parameterized-quantum-circuits-demo">1. Parameterized Quantum Circuits Demo</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qvc-demo">2. QVC demo</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quantum-circuit">Quantum circuit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model-building">Model building</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model-training-and-testing">Model training and testing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#data-re-uploading-algorithm">3. data re-uploading algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vsql-variational-shadow-quantum-learning-for-classification-model">4. VSQL: Variational Shadow Quantum Learning for Classification Model</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quantum-autoencoder-demo">Quantum AutoEncoder Demo</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quantum-autoencoder">1.Quantum AutoEncoder</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quantum-circuits-structure-learning-demo">Quantum Circuits Structure Learning Demo</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quantum-circuits-structure-learning">1.Quantum circuits structure learning</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hybird-quantum-classic-nerual-network-demo">Hybird Quantum Classic Nerual Network Demo</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hybrid-quantum-classic-neural-network-model">1.Hybrid Quantum Classic Neural Network Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-preparation">Data Preparation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#construct-quantum-circuits">Construct Quantum Circuits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#create-hybird-model">Create Hybird Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#training-and-testing">Training and testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#visualization">Visualization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hybrid-quantum-classical-transfer-learning-model">2.Hybrid quantum classical transfer learning model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hybrid-quantum-classical-unet-network-model">3.Hybrid quantum classical Unet network model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">Data preparation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#constructing-quantum-circuits">Constructing quantum circuits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#constructing-hybrid-classical-quantum-neural-network">Constructing hybrid classical quantum neural network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#training-and-model-saving">Training and model saving</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-visualization">Data visualization</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#unsupervised-learning">Unsupervised learning</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quantum-kmeans">1 Quantum Kmeans</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduce">1.1 Introduce</a></li>
<li class="toctree-l4"><a class="reference internal" href="#introduction-to-algorithm-principle">1.2 Introduction to algorithm principle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vqnet-implementation">1.3 VQNet  implementation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#model-training-using-quantum-computing-layer-in-vqnet">Model training using quantum computing layer in VQNet</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#model-training-using-quantumlayer-in-vqnet">Model training using quantumlayer in VQNet</a></li>
<li class="toctree-l3"><a class="reference internal" href="#model-training-using-noisequantumlayer-in-vqnet">Model training using NoiseQuantumLayer in VQNet</a></li>
<li class="toctree-l3"><a class="reference internal" href="#run-model-training-of-qiskit-line-in-vqnet-using-qiskitlayer">Run model training of qiskit line in VQNet using QiskitLayer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#model-training-using-vqclayer-in-vqnet">Model training using VQCLayer in VQNet</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">The API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="QTensor.html">QTensor Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="nn.html">Classical Neural Network Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="qnn.html">Quantum Machine Learning Module</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">VQNET</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Quantum Machine Learning Demos</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/rst/qml_demo.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quantum-machine-learning-demos">
<h1>Quantum Machine Learning Demos<a class="headerlink" href="#quantum-machine-learning-demos" title="Permalink to this headline">¶</a></h1>
<p>The following are some examples of quantum machine learning algorithms.</p>
<section id="application-of-parameterized-quantum-circuit-in-classification-task">
<h2>Application of Parameterized Quantum Circuit in Classification Task<a class="headerlink" href="#application-of-parameterized-quantum-circuit-in-classification-task" title="Permalink to this headline">¶</a></h2>
<section id="parameterized-quantum-circuits-demo">
<h3>1. Parameterized Quantum Circuits Demo<a class="headerlink" href="#parameterized-quantum-circuits-demo" title="Permalink to this headline">¶</a></h3>
<p>PQC is a quantum circuit with trainable parameters.
The quantum circuit with parameters here is defined by <a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/">pyQPanda</a>.
We first use an encoding quantum circuit to encode classica data into a quantum state.
The classic data encoding circuit is not fixed, an IQP encoding circuit is used here.
7 RX quantum logic gates are used , and 7 classic data features are respectively encoded on 4 qubits.
Next is the quantum circuit part with variable parameters. We use HardwareEfficientAnsatz here.
First, 4 qubits are placed on the <code class="docutils literal notranslate"><span class="pre">RX</span></code> gate, and then a combination of 3 <code class="docutils literal notranslate"><span class="pre">Z</span></code> gates and 4 <code class="docutils literal notranslate"><span class="pre">RZ</span></code> gates is inserted.
The Hamiltonian measurement of the PQC quantum circuit is used as the prediction of model to optimize the classification task.</p>
<p><a class="reference external" href="../../../../../tutorials/PQC/PQC_demo.md">PQC introduction</a> ,  <a class="reference external" href="../../../../examples/pqc_test.py">PQC demo code</a></p>
<blockquote>
<div><blockquote>
<div><p>Encoder Circuits</p>
<figure class="align-default">
<img alt="../_images/pqccir1.png" src="../_images/pqccir1.png" />
</figure>
<p>Ansatz Circuits</p>
<figure class="align-default">
<img alt="../_images/pqccir2.png" src="../_images/pqccir2.png" />
</figure>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Parameterized Quantum Circuits demo</span>

<span class="sd">ref: ..\\..\\tutorials\PQC\\PQC demo.md</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.linear</span> <span class="kn">import</span> <span class="n">Linear</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">CategoricalCrossEntropy</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim.sgd</span> <span class="kn">import</span> <span class="n">SGD</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim.adam</span> <span class="kn">import</span> <span class="n">Adam</span>
<span class="kn">from</span> <span class="nn">pyvqnet.data.data</span> <span class="kn">import</span> <span class="n">data_generator</span>
<span class="kn">from</span> <span class="nn">pyvqnet.qnn.pqc.pqc</span> <span class="kn">import</span> <span class="n">PQCLayer</span>

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;TkAgg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pqc</span> <span class="o">=</span> <span class="n">PQCLayer</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pqc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">load_iris</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;training_data&quot;</span><span class="p">,</span>
                <span class="n">path</span><span class="o">=</span><span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">..</span><span class="se">\\</span><span class="s2">data</span><span class="se">\\</span><span class="s2">iris.npz&quot;</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
        <span class="c1">#train_x,test_x,train_y,test_y</span>
        <span class="n">train_x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;train_x&#39;</span><span class="p">]</span>
        <span class="n">test_x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;test_x&#39;</span><span class="p">]</span>
        <span class="n">train_y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;train_y&#39;</span><span class="p">]</span>
        <span class="n">test_y</span>  <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;test_y&#39;</span><span class="p">]</span>

    <span class="c1">#convert to onehot label</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">train_y</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">train_y</span><span class="p">))</span>
    <span class="n">train_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">train_y</span><span class="p">]</span>
    <span class="n">test_y</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">test_y</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">train_x</span><span class="p">,</span><span class="n">test_x</span><span class="p">,</span><span class="n">train_y</span><span class="p">,</span><span class="n">test_y</span>

<span class="k">def</span> <span class="nf">run2</span><span class="p">():</span>
    <span class="n">x_train</span><span class="p">,</span><span class="n">x_test</span><span class="p">,</span><span class="n">y_train</span><span class="p">,</span><span class="n">y_test</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">(</span><span class="s2">&quot;training_data&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;model start&quot;</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>

    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span><span class="n">lr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>

    <span class="n">train_loss</span>  <span class="o">=</span> <span class="p">[]</span>
    <span class="n">train_acc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">eval_loss</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">eval_acc</span> <span class="o">=</span><span class="p">[]</span>
    <span class="n">F1</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;rlt.txt&quot;</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;epoch </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
        <span class="n">full_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_eval</span> <span class="o">=</span><span class="mi">0</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span><span class="mi">5</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">lr</span>  <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">lr</span> <span class="o">*</span><span class="mf">0.1</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span><span class="c1">#shuffle batch rather than data</span>

            <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">x</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">x</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">x0</span><span class="p">],</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="nb">iter</span> <span class="o">+=</span><span class="mi">1</span>

            <span class="n">CCEloss</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">CCEloss</span><span class="p">(</span> <span class="n">y</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

            <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>
            <span class="n">full_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="o">*</span><span class="n">batch_size</span>
            <span class="n">n_loss</span> <span class="o">+=</span> <span class="n">batch_size</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Epoch:&quot;</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="s2">&quot;batch_processed:&quot;</span><span class="p">,</span> <span class="n">n_loss</span><span class="p">,</span> <span class="s2">&quot;loss:&quot;</span><span class="p">,</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
            <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">mask</span>  <span class="o">=</span> <span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">correct</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Train Accuracy: </span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_loss</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">, Loss: </span><span class="si">{</span><span class="n">full_loss</span> <span class="o">/</span> <span class="n">n_loss</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">F1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">full_loss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_loss</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_loss</span><span class="si">}</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">train_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">full_loss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_loss</span> <span class="p">)</span>
        <span class="n">train_acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">correct</span><span class="o">/</span><span class="n">n_loss</span><span class="p">)</span>

        <span class="c1"># Evaluation</span>
        <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">full_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">x</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">x</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">x0</span><span class="p">],</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">CCEloss</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>

            <span class="n">loss</span> <span class="o">=</span> <span class="n">CCEloss</span><span class="p">(</span> <span class="n">y</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>

            <span class="n">full_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Epoch:&quot;</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="s2">&quot;iter:&quot;</span><span class="p">,</span> <span class="n">n_loss</span><span class="p">,</span> <span class="s2">&quot;loss:&quot;</span><span class="p">,</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
            <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">mask</span>  <span class="o">=</span> <span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">correct</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">n_eval</span> <span class="o">+=</span> <span class="n">batch_size</span>
            <span class="n">n_loss</span> <span class="o">+=</span> <span class="n">batch_size</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Eval Accuracy: </span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_eval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">F1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">full_loss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_loss</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_eval</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">eval_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">full_loss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_loss</span> <span class="p">)</span>
        <span class="n">eval_acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">correct</span><span class="o">/</span><span class="n">n_loss</span><span class="p">)</span>
    <span class="n">F1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">del</span> <span class="n">model</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">run2</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>Curve of the loss function on the iris 2-class classification database：</p>
<figure class="align-default">
<img alt="../_images/pqcloss.png" src="../_images/pqcloss.png" />
</figure>
</section>
<section id="qvc-demo">
<h3>2. QVC demo<a class="headerlink" href="#qvc-demo" title="Permalink to this headline">¶</a></h3>
<p>This example uses VQNet to implement the algorithm in the thesis: <a class="reference external" href="https://arxiv.org/pdf/1804.00633.pdf">Circuit-centric quantum classifiers</a>  .
This example is used to determine whether a binary number is odd or even. By encoding the binary number onto the qubit and optimizing the variable parameters in the circuit,
the z-direction observation of the circuit can indicate whether the input is odd or even.</p>
<p><a class="reference external" href="../../../../../tutorials/QVC/QVC_demo.md">QVC Algorithm introduction</a> , <a class="reference external" href="../../../../examples/qvc_quantumlayer_test.py">QVC demo code</a></p>
<section id="quantum-circuit">
<h4>Quantum circuit<a class="headerlink" href="#quantum-circuit" title="Permalink to this headline">¶</a></h4>
<p>The variable component sub-circuit usually defines a sub-circuit, which is a basic circuit architecture, and complex variational circuits can be constructed by repeating layers.
Our circuit layer consists of multiple rotating quantum logic gates and <code class="docutils literal notranslate"><span class="pre">CNOT</span></code> quantum logic gates that entangle each qubit with its neighboring qubits.
We also need a circuit to encode classical data into a quantum state, so that the output of the circuit measurement is related to the input.
In this example, we encode the binary input onto the qubits in the corresponding order. For example, the input data 1101 is encoded into 4 qubits.</p>
<div class="math notranslate nohighlight">
\[x = 1101 \rightarrow|\psi\rangle=|1101\rangle\]</div>
<figure class="align-default">
<img alt="../_images/qvc_circuit.png" src="../_images/qvc_circuit.png" />
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyqpanda</span> <span class="k">as</span> <span class="nn">pq</span>

<span class="k">def</span> <span class="nf">qvc_circuits</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">weights</span><span class="p">,</span><span class="n">qlist</span><span class="p">,</span><span class="n">clist</span><span class="p">,</span><span class="n">machine</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">get_cnot</span><span class="p">(</span><span class="n">nqubits</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nqubits</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">nqubits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nqubits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">nqubits</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">nqubits</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">nqubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">cir</span>

    <span class="k">def</span> <span class="nf">build_circult</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">nqubits</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">Rot</span><span class="p">(</span><span class="n">weights_j</span><span class="p">,</span> <span class="n">qubits</span><span class="p">):</span>
            <span class="n">circult</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
            <span class="n">circult</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RZ</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">weights_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">circult</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">weights_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">circult</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RZ</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">weights_j</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">circult</span>
        <span class="k">def</span> <span class="nf">basisstate</span><span class="p">():</span>
            <span class="n">circult</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nqubits</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">xx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">circult</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="n">nqubits</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">circult</span>

        <span class="n">circult</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="n">circult</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">basisstate</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="n">weights_i</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nqubits</span><span class="p">)):</span>
                <span class="n">weights_j</span> <span class="o">=</span> <span class="n">weights_i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">circult</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Rot</span><span class="p">(</span><span class="n">weights_j</span><span class="p">,</span><span class="n">nqubits</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">cnots</span> <span class="o">=</span> <span class="n">get_cnot</span><span class="p">(</span><span class="n">nqubits</span><span class="p">)</span>
            <span class="n">circult</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cnots</span><span class="p">)</span>

        <span class="n">circult</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="n">nqubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">circult</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prog</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">build_circult</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span><span class="nb">input</span><span class="p">,</span><span class="n">qlist</span><span class="p">)</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">prob_run_dict</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">prob</span>
</pre></div>
</div>
</section>
<section id="model-building">
<h4>Model building<a class="headerlink" href="#model-building" title="Permalink to this headline">¶</a></h4>
<p>We have defined variable quantum circuits <code class="docutils literal notranslate"><span class="pre">qvc_circuits</span></code> .
We hope to use it in our VQNet’s automatic differentiation logic,
and use VQNet’s optimization algorithm for model training.
We define a Model class, which inherits from the abstract class Module.
The model uses the <a class="reference internal" href="qnn.html#quantumlayer"><span class="std std-ref">QuantumLayer</span></a> class, which is a quantum computing layer that can be automatically differentiated.
qvc_circuits is the quantum circuit we want to run,
24 is the number of all quantum circuit parameters that need to be trained,
“cpu” means that pyQPanda’s full amplitude simulator is used here,
and 4 means that 4 qubits need to be applied for.
In the <code class="docutils literal notranslate"><span class="pre">forward()</span></code> function, the user defines the logic of the model to run forward.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim.sgd</span> <span class="kn">import</span> <span class="n">SGD</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">CategoricalCrossEntropy</span>
<span class="kn">from</span> <span class="nn">pyvqnet.tensor.tensor</span> <span class="kn">import</span> <span class="n">QTensor</span>
<span class="kn">import</span> <span class="nn">pyqpanda</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">from</span> <span class="nn">pyvqnet.qnn.quantumlayer</span> <span class="kn">import</span> <span class="n">QuantumLayer</span>
<span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qvc</span> <span class="o">=</span> <span class="n">QuantumLayer</span><span class="p">(</span><span class="n">qvc_circuits</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qvc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="model-training-and-testing">
<h4>Model training and testing<a class="headerlink" href="#model-training-and-testing" title="Permalink to this headline">¶</a></h4>
<p>We use pre-generated random binary numbers and their odd and even labels.
The data is in qvc_data.txt and qvc_data_test.txt
in the data directory of the VQNet root directory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">PATH</span><span class="p">):</span>
    <span class="n">datasets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">PATH</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">label</span>

<span class="k">def</span> <span class="nf">dataloader</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="n">batch_size</span><span class="p">):</span>
            <span class="n">random_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">random_index</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">label</span><span class="p">[</span><span class="n">random_index</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="n">batch_size</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">batch_size</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">batch_size</span><span class="p">],</span> <span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">batch_size</span><span class="p">]</span>

<span class="n">PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;.//data//qvc_data.txt&#39;</span><span class="p">)</span>
<span class="n">datas</span><span class="p">,</span><span class="n">labels</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">PATH</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">datas</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

<span class="n">PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;.//data//qvc_data_test.txt&#39;</span><span class="p">)</span>
<span class="n">datas</span><span class="p">,</span><span class="n">labels</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">PATH</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">datas</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
<p>Then you can perform model forwarding, loss function calculation,
reverse calculation, optimizer calculation according to the general
neural network training mode,until the number of iterations reaches the preset value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_accuary</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">label</span><span class="p">):</span>
    <span class="n">result</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">score</span>

<span class="c1">#Example Model Class</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>
<span class="c1">#Create a SGD  optimizer to optimize the model&#39;s parameters</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span><span class="n">lr</span> <span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="c1">#set batch_size = 3</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1">#maximum epochs</span>
<span class="n">epoch</span> <span class="o">=</span> <span class="mi">20</span>
<span class="c1">#model&#39;s loss function</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>

<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
<span class="n">PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;qvc_data.txt&#39;</span><span class="p">)</span>
<span class="n">datas</span><span class="p">,</span><span class="n">labels</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">PATH</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epoch</span><span class="p">):</span>
    <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">sum_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">accuary</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">data</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">(</span><span class="n">datas</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="n">batch_size</span><span class="p">,</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">data</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">loss_b</span> <span class="o">=</span> <span class="n">loss</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">result</span><span class="p">)</span>
        <span class="n">loss_b</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>
        <span class="n">sum_loss</span> <span class="o">+=</span> <span class="n">loss_b</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">count</span><span class="o">+=</span><span class="n">batch_size</span>
        <span class="n">accuary</span> <span class="o">+=</span> <span class="n">get_accuary</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;epoch:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, #### loss:</span><span class="si">{</span><span class="n">sum_loss</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2"> #####accuray:</span><span class="si">{</span><span class="n">accuary</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">test_PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;qvc_data_test.txt&#39;</span><span class="p">)</span>
<span class="n">test_data</span><span class="p">,</span> <span class="n">test_label</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">test_PATH</span><span class="p">)</span>
<span class="n">test_batch_size</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">accuary</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">sum_loss</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">testd</span><span class="p">,</span><span class="n">testl</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">(</span><span class="n">test_data</span><span class="p">,</span><span class="n">test_label</span><span class="p">,</span><span class="n">test_batch_size</span><span class="p">):</span>
    <span class="n">testd</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">testd</span><span class="p">)</span>
    <span class="n">test_result</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">testd</span><span class="p">)</span>
    <span class="n">test_loss</span> <span class="o">=</span> <span class="n">loss</span><span class="p">(</span><span class="n">testl</span><span class="p">,</span><span class="n">test_result</span><span class="p">)</span>
    <span class="n">sum_loss</span> <span class="o">+=</span> <span class="n">test_loss</span>
    <span class="n">count</span><span class="o">+=</span><span class="n">test_batch_size</span>
    <span class="n">accuary</span> <span class="o">+=</span> <span class="n">get_accuary</span><span class="p">(</span><span class="n">test_result</span><span class="p">,</span><span class="n">testl</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;test:---------------&gt;loss:</span><span class="si">{</span><span class="n">sum_loss</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2"> #####accuray:</span><span class="si">{</span><span class="n">accuary</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">epoch</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="c1">#### loss:0.20194714764753977 #####accuray:0.6666666666666666</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="c1">#### loss:0.19724808633327484 #####accuray:0.8333333333333334</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="c1">#### loss:0.19266503552595773 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="c1">#### loss:0.18812804917494455 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="c1">#### loss:0.1835678368806839 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="c1">#### loss:0.1789149840672811 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="c1">#### loss:0.17410411685705185 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="c1">#### loss:0.16908332953850427 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="c1">#### loss:0.16382796317338943 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span> <span class="c1">#### loss:0.15835540741682053 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="c1">#### loss:0.15273457020521164 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span> <span class="c1">#### loss:0.14708336691061655 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="c1">#### loss:0.14155150949954987 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">13</span><span class="p">,</span> <span class="c1">#### loss:0.1362930883963903 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">14</span><span class="p">,</span> <span class="c1">#### loss:0.1314386005202929 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">15</span><span class="p">,</span> <span class="c1">#### loss:0.12707658857107162 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span> <span class="c1">#### loss:0.123248390853405 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="c1">#### loss:0.11995399743318558 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">18</span><span class="p">,</span> <span class="c1">#### loss:0.1171633576353391 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">19</span><span class="p">,</span> <span class="c1">#### loss:0.11482855677604675 #####accuray:1.0</span>
<span class="p">[</span><span class="mf">0.3412148654</span><span class="p">]</span>
<span class="n">test</span><span class="p">:</span><span class="o">---------------&gt;</span><span class="n">loss</span><span class="p">:</span><span class="n">QTensor</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#####accuray:1.0</span>
</pre></div>
</div>
<p>The folling picture illustrates the curve of model’s accuracy:</p>
<figure class="align-default">
<img alt="../_images/qvc_accuracy.png" src="../_images/qvc_accuracy.png" />
</figure>
</section>
</section>
<section id="data-re-uploading-algorithm">
<h3>3. data re-uploading algorithm<a class="headerlink" href="#data-re-uploading-algorithm" title="Permalink to this headline">¶</a></h3>
<p>In a neural network, each neuron receives information from all neurons in the upper layer (Figure a).
In contrast, the single-bit quantum classifier accepts the previous information processing unit and input (Figure b).
For traditional quantum circuits, when the data is uploaded, the result can be obtained directly through several unitary
transformations: math:<cite>U(theta_1,theta_2,theta_3)</cite>.However, in the Quantum Data Re upLoading (QDRL) task, the data needs to be re-uploaded before every unitary transformation.</p>
<blockquote>
<div><p class="centered">
<strong>Comparison of QDRL and classic neural network schematics</strong></p></div></blockquote>
<figure class="align-default">
<img alt="../_images/qdrl.png" src="../_images/qdrl.png" />
</figure>
<p><a class="reference external" href="../../../../../tutorials/QDRL/QDRL_demo.md">QDRL algorithm introduction</a> , <a class="reference external" href="../../../../examples/qdrl_test.py">QDRL demo code</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Parameterized quantum circuit for Quantum Data Re-upLoading</span>

<span class="sd">ref: ..\\..\\tutorials\QDRL\\QDRL demo.md</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.linear</span> <span class="kn">import</span> <span class="n">Linear</span>
<span class="kn">from</span> <span class="nn">pyvqnet.qnn.qdrl.vqnet_model</span> <span class="kn">import</span> <span class="n">vmodel</span>
<span class="kn">from</span> <span class="nn">pyvqnet</span> <span class="kn">import</span> <span class="n">_core</span> <span class="k">as</span> <span class="n">vcore</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim</span> <span class="kn">import</span> <span class="n">sgd</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn</span> <span class="kn">import</span> <span class="n">loss</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">CategoricalCrossEntropy</span>
<span class="c1">#hyperparameters</span>
<span class="kn">from</span> <span class="nn">pyvqnet.tensor.tensor</span> <span class="kn">import</span> <span class="n">QTensor</span>
<span class="kn">from</span> <span class="nn">pyvqnet.tensor</span> <span class="kn">import</span> <span class="n">tensor</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;TkAgg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="n">num_layers</span> <span class="o">=</span>  <span class="mi">3</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_layers</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1">#Create a Module to define the model</span>
<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pqc</span> <span class="o">=</span> <span class="n">vmodel</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pqc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">circle</span><span class="p">(</span><span class="n">samples</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span>  <span class="n">reps</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="p">:</span>
    <span class="n">data_x</span><span class="p">,</span> <span class="n">data_y</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">reps</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">data_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_y</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">plot_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot data with red/blue values for a binary classification.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array[tuple]): array of data points as tuples</span>
<span class="sd">        y (array[int]): array of data points as tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="n">reds</span> <span class="o">=</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">blues</span> <span class="o">=</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">reds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">reds</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">blues</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">blues</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;$x_1$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;$x_2$&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_minibatch_data</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x_data</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">batch_size</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">batch_size</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">x_data</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">batch_size</span><span class="p">)]),</span>
        <span class="n">label</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">batch_size</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">batch_size</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">get_score</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
    <span class="n">pred</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">score</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">sgd</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span><span class="n">lr</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">5</span>
<span class="c1">#train on random genearated samples</span>
<span class="k">def</span> <span class="nf">train</span><span class="p">():</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">circle</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
    <span class="n">x_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x_train</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))))</span>  <span class="c1"># 500*3</span>
    <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">x_train</span><span class="p">),</span><span class="n">QTensor</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span>
    <span class="n">epoch</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start training...........&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epoch</span><span class="p">):</span>
        <span class="n">accuracy</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">get_minibatch_data</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span><span class="n">batch_size</span><span class="p">):</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>

            <span class="n">data</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="n">Closs</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>
            <span class="n">losss</span> <span class="o">=</span> <span class="n">Closs</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

            <span class="n">losss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>

            <span class="n">accuracy</span> <span class="o">+=</span> <span class="n">get_score</span><span class="p">(</span><span class="n">output</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">+=</span> <span class="n">losss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;epoch:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, train_accuracy:</span><span class="si">{</span><span class="n">accuracy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;epoch:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, train_loss:</span><span class="si">{</span><span class="n">losss</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getdata</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">batch_size</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;epoch:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, train_accuracy_for_each_batch:</span><span class="si">{</span><span class="n">accuracy</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;epoch:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, train_loss_for_each_batch:</span><span class="si">{</span><span class="n">loss</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1">#test on random genearated samples</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start eval...................&quot;</span><span class="p">)</span>
    <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">circle</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
    <span class="n">test_accuracy</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x_test</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))))</span>
    <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">x_test</span><span class="p">),</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">y_test</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">test_data</span><span class="p">,</span> <span class="n">test_label</span> <span class="ow">in</span> <span class="n">get_minibatch_data</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span><span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>

        <span class="n">test_data</span><span class="p">,</span> <span class="n">test_label</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">test_data</span><span class="p">),</span><span class="n">QTensor</span><span class="p">(</span><span class="n">test_label</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span>
        <span class="n">test_accuracy</span> <span class="o">+=</span> <span class="n">get_score</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">test_label</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">batch_size</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;test_accuracy:</span><span class="si">{</span><span class="n">test_accuracy</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">train</span><span class="p">()</span>
    <span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
<p>The folling picture illustrates the curve of model’s accuracy：</p>
<figure class="align-default">
<img alt="../_images/qdrl_accuracy.png" src="../_images/qdrl_accuracy.png" />
</figure>
</section>
<section id="vsql-variational-shadow-quantum-learning-for-classification-model">
<h3>4. VSQL: Variational Shadow Quantum Learning for Classification Model<a class="headerlink" href="#vsql-variational-shadow-quantum-learning-for-classification-model" title="Permalink to this headline">¶</a></h3>
<p>Using variable quantum circuits to construct a two-class classification model,
comparing the classification accuracy with a neural network with similar parameter accuracy,
the accuracy of the two is similar. The quantity of parameters of quantum circuits is much smaller than that of classical neural networks.
The algorithm is based on the paper: <a class="reference external" href="https://arxiv.org/abs/2012.08288">Variational Shadow Quantum Learning for Classification Model</a> to
reproduce.</p>
<p><a class="reference external" href="../../../../../tutorials/VSQL/VSQL_demo.md">VSQL model introduction</a>  ,  <a class="reference external" href="../../../../examples/qnn_mnist_vsql.py">VSQL demo code</a></p>
<p>Following figure shows the architecture of VSQL algorithm:</p>
<figure class="align-default">
<img alt="../_images/vsql_model.PNG" src="../_images/vsql_model.PNG" />
</figure>
<p>Following figures show the local quantum circuits structure on each qubits:</p>
<figure class="align-default">
<img alt="../_images/vsql_0.png" src="../_images/vsql_0.png" />
</figure>
<figure class="align-default">
<img alt="../_images/vsql_1.png" src="../_images/vsql_1.png" />
</figure>
<figure class="align-default">
<img alt="../_images/vsql_2.png" src="../_images/vsql_2.png" />
</figure>
<figure class="align-default">
<img alt="../_images/vsql_3.png" src="../_images/vsql_3.png" />
</figure>
<figure class="align-default">
<img alt="../_images/vsql_4.png" src="../_images/vsql_4.png" />
</figure>
<figure class="align-default">
<img alt="../_images/vsql_5.png" src="../_images/vsql_5.png" />
</figure>
<figure class="align-default">
<img alt="../_images/vsql_6.png" src="../_images/vsql_6.png" />
</figure>
<figure class="align-default">
<img alt="../_images/vsql_7.png" src="../_images/vsql_7.png" />
</figure>
<figure class="align-default">
<img alt="../_images/vsql_8.png" src="../_images/vsql_8.png" />
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Parameterized quantum circuit for VSQL</span>

<span class="sd">ref: ..\\..\\tutorials\VSQL\\VSQL demo.md</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.linear</span> <span class="kn">import</span> <span class="n">Linear</span>

<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">CategoricalCrossEntropy</span>

<span class="kn">from</span> <span class="nn">pyvqnet.optim.adam</span> <span class="kn">import</span> <span class="n">Adam</span>
<span class="kn">from</span> <span class="nn">pyvqnet.data.data</span> <span class="kn">import</span> <span class="n">data_generator</span>
<span class="kn">from</span> <span class="nn">pyvqnet.tensor</span> <span class="kn">import</span> <span class="n">tensor</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">pyqpanda</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;TkAgg&#39;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">pyvqnet.qnn.measure</span> <span class="kn">import</span> <span class="n">expval</span>
<span class="kn">from</span> <span class="nn">pyvqnet.qnn.quantumlayer</span> <span class="kn">import</span> <span class="n">QuantumLayer</span>
<span class="kn">from</span> <span class="nn">pyvqnet.qnn.template</span> <span class="kn">import</span> <span class="n">AmplitudeEmbeddingCircuit</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.linear</span> <span class="kn">import</span> <span class="n">Linear</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;./result&quot;</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="s2">&quot;./result&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">circuits_of_vsql</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">weights</span><span class="p">,</span><span class="n">qlist</span><span class="p">,</span><span class="n">clist</span><span class="p">,</span><span class="n">machine</span><span class="p">):</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">n_qsc</span><span class="o">=</span><span class="mi">2</span>
    <span class="n">depth</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n_qsc</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">subcir</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span><span class="n">qlist</span><span class="p">,</span><span class="n">depth</span><span class="p">,</span><span class="n">n_qsc</span><span class="p">,</span><span class="n">n_start</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qsc</span><span class="p">):</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RX</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">n_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">))</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">n_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RX</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">n_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">repeat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qsc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">n_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="n">qlist</span><span class="p">[</span><span class="n">n_start</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">n_start</span> <span class="o">+</span> <span class="n">n_qsc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span><span class="n">qlist</span><span class="p">[</span> <span class="n">n_start</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qsc</span><span class="p">):</span>
                <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span> <span class="n">n_start</span> <span class="o">+</span> <span class="n">i</span><span class="p">],</span> <span class="n">weights</span><span class="p">[</span><span class="n">repeat</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">cir</span>
    <span class="k">def</span> <span class="nf">get_pauli_str</span><span class="p">(</span><span class="n">n_start</span><span class="p">,</span> <span class="n">n_qsc</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">pauli_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;X&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_start</span><span class="p">,</span> <span class="n">n_start</span> <span class="o">+</span> <span class="n">n_qsc</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">pauli_str</span><span class="p">:</span><span class="mf">1.0</span><span class="p">}</span>

    <span class="n">f_i</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">n_qsc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">get_pauli_str</span><span class="p">(</span><span class="n">st</span><span class="p">,</span><span class="n">n_qsc</span><span class="p">)</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">AmplitudeEmbeddingCircuit</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">qlist</span><span class="p">))</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">subcir</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span><span class="n">qlist</span><span class="p">,</span><span class="n">depth</span><span class="p">,</span><span class="n">n_qsc</span><span class="p">,</span><span class="n">st</span><span class="p">))</span>
        <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cir</span><span class="p">)</span>

        <span class="n">f_ij</span> <span class="o">=</span> <span class="n">expval</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span><span class="n">prog</span><span class="p">,</span><span class="n">psd</span><span class="p">,</span><span class="n">qlist</span><span class="p">)</span>
        <span class="n">f_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_ij</span><span class="p">)</span>
    <span class="n">f_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f_i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f_i</span>

<span class="c1">#GLOBAL VAR</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">n_qsc</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1">#define the quantum module</span>
<span class="k">class</span> <span class="nc">QModel</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vq</span> <span class="o">=</span> <span class="n">QuantumLayer</span><span class="p">(</span><span class="n">circuits_of_vsql</span><span class="p">,(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span> <span class="n">n_qsc</span><span class="p">,</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">n_qsc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vq</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">28</span><span class="o">*</span><span class="mi">28</span><span class="p">,</span><span class="n">output_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">load_mnist</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;training_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
                <span class="n">path</span><span class="o">=</span><span class="s2">&quot;..</span><span class="se">\\</span><span class="s2">..</span><span class="se">\\</span><span class="s2">data</span><span class="se">\\</span><span class="s2">MNIST_data</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">struct</span>
    <span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">pyarray</span>
    <span class="k">if</span> <span class="n">dataset</span> <span class="o">==</span> <span class="s2">&quot;training_data&quot;</span><span class="p">:</span>
        <span class="n">fname_image</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;train-images.idx3-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">fname_label</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;train-labels.idx1-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dataset</span> <span class="o">==</span> <span class="s2">&quot;testing_data&quot;</span><span class="p">:</span>
        <span class="n">fname_image</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;t10k-images.idx3-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">fname_label</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;t10k-labels.idx1-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dataset must be &#39;training_data&#39; or &#39;testing_data&#39;&quot;</span><span class="p">)</span>

    <span class="n">flbl</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_label</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
    <span class="n">magic_nr</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;II&quot;</span><span class="p">,</span> <span class="n">flbl</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="n">lbl</span> <span class="o">=</span> <span class="n">pyarray</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">flbl</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="n">flbl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">fimg</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_image</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
    <span class="n">magic_nr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;IIII&quot;</span><span class="p">,</span> <span class="n">fimg</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">pyarray</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">fimg</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="n">fimg</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">lbl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="n">digits</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>

    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
        <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">:</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lbl</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">def</span> <span class="nf">show_image</span><span class="p">():</span>
    <span class="n">image</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="p">)):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">img</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">compared classic fc model</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">def</span> <span class="nf">run_fc01</span><span class="p">():</span>

    <span class="n">digits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;training_data&quot;</span><span class="p">,</span><span class="n">digits</span><span class="p">)</span>
    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span> <span class="o">/</span> <span class="mi">255</span>


    <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">))[</span><span class="n">y_train</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">))</span>

    <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;testing_data&quot;</span><span class="p">,</span><span class="n">digits</span><span class="p">)</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">))[</span><span class="n">y_test</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">))</span>


    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="p">[:</span><span class="mi">500</span><span class="p">]</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[:</span><span class="mi">500</span><span class="p">]</span>

    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="p">[:</span><span class="mi">100</span><span class="p">]</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="p">[:</span><span class="mi">100</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;model start&quot;</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>

    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span><span class="n">lr</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    <span class="n">F1</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./result/qfcrlt.txt&quot;</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">):</span>

        <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
        <span class="n">full_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_eval</span> <span class="o">=</span><span class="mi">0</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">128</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span><span class="c1">#shuffle batch rather than data</span>

            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">28</span><span class="p">,</span><span class="mi">28</span><span class="p">)</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="nb">iter</span> <span class="o">+=</span><span class="mi">1</span>

            <span class="n">CCEloss</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">CCEloss</span><span class="p">(</span> <span class="n">y</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>

            <span class="n">full_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">n_loss</span> <span class="o">+=</span> <span class="n">batch_size</span>
            <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">mask</span>  <span class="o">=</span> <span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">correct</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Train Accuracy: </span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_loss</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">, Loss: </span><span class="si">{</span><span class="n">full_loss</span> <span class="o">/</span> <span class="n">n_loss</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">F1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">full_loss</span> <span class="o">/</span> <span class="n">n_loss</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_loss</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Evaluation</span>
        <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;eval&quot;</span><span class="p">)</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">full_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">CCEloss</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>

            <span class="n">loss</span> <span class="o">=</span> <span class="n">CCEloss</span><span class="p">(</span> <span class="n">y</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>

            <span class="n">full_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">mask</span>  <span class="o">=</span> <span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">correct</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">n_eval</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">n_loss</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Eval Accuracy: </span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_eval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">F1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">full_loss</span> <span class="o">/</span> <span class="n">n_loss</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_eval</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">F1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">model</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">done</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">VSQL MODEL</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">def</span> <span class="nf">run_VSQL</span><span class="p">():</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;training_data&quot;</span><span class="p">,</span><span class="n">digits</span><span class="p">)</span>
    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">))[</span><span class="n">y_train</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">))</span>
    <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;testing_data&quot;</span><span class="p">,</span><span class="n">digits</span><span class="p">)</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">))[</span><span class="n">y_test</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">))</span>

    <span class="n">x_train_list</span> <span class="o">=</span><span class="p">[]</span>
    <span class="n">x_test_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">x_train_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x_train</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">240</span><span class="p">),</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="n">x_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x_train_list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">x_test_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x_test</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">240</span><span class="p">),</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>

    <span class="n">x_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x_test_list</span><span class="p">)</span>

    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="p">[:</span><span class="mi">500</span><span class="p">]</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[:</span><span class="mi">500</span><span class="p">]</span>

    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="p">[:</span><span class="mi">100</span><span class="p">]</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="p">[:</span><span class="mi">100</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;model start&quot;</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">QModel</span><span class="p">()</span>

    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span><span class="n">lr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    <span class="n">F1</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./result/vqslrlt.txt&quot;</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">):</span>

        <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
        <span class="n">full_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_eval</span> <span class="o">=</span><span class="mi">0</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1024</span><span class="p">)</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="nb">iter</span> <span class="o">+=</span><span class="mi">1</span>

            <span class="n">CCEloss</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">CCEloss</span><span class="p">(</span> <span class="n">y</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>

            <span class="n">full_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">n_loss</span> <span class="o">+=</span> <span class="n">batch_size</span>
            <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">mask</span>  <span class="o">=</span> <span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">correct</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">iter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Train Accuracy: </span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_loss</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">, Loss: </span><span class="si">{</span><span class="n">full_loss</span> <span class="o">/</span> <span class="n">n_loss</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">F1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">full_loss</span> <span class="o">/</span> <span class="n">n_loss</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_loss</span><span class="si">}</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Evaluation</span>
        <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;eval&quot;</span><span class="p">)</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">full_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">CCEloss</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">CCEloss</span><span class="p">(</span> <span class="n">y</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
            <span class="n">full_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">mask</span>  <span class="o">=</span> <span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">correct</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">n_eval</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">n_loss</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Eval Accuracy: </span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_eval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">F1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">full_loss</span> <span class="o">/</span> <span class="n">n_loss</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_eval</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">F1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">model</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">done vqsl</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="n">run_VSQL</span><span class="p">()</span>
</pre></div>
</div>
<p>The following shows the curve of model’s accuacy and loss：</p>
<figure class="align-default">
<img alt="../_images/vsql_cacc.PNG" src="../_images/vsql_cacc.PNG" />
</figure>
<figure class="align-default">
<img alt="../_images/vsql_closs.PNG" src="../_images/vsql_closs.PNG" />
</figure>
<figure class="align-default">
<img alt="../_images/vsql_qacc.PNG" src="../_images/vsql_qacc.PNG" />
</figure>
<figure class="align-default">
<img alt="../_images/vsql_qloss.PNG" src="../_images/vsql_qloss.PNG" />
</figure>
</section>
</section>
<section id="quantum-autoencoder-demo">
<h2>Quantum AutoEncoder Demo<a class="headerlink" href="#quantum-autoencoder-demo" title="Permalink to this headline">¶</a></h2>
<section id="quantum-autoencoder">
<h3>1.Quantum AutoEncoder<a class="headerlink" href="#quantum-autoencoder" title="Permalink to this headline">¶</a></h3>
<p>The classic autoencoder is a neural network that can learn high-efficiency low-dimensional representations of data in a high-dimensional space.
The task of the autoencoder is to map x to a low-dimensional point y given an input x, so that x can be recovered from y.
The structure of the underlying autoencoder network can be selected to represent the data in a smaller dimension, thereby effectively compressing the input.
Inspired by this idea, the model of quantum autoencoder is used to perform similar tasks on quantum data.
Quantum autoencoders are trained to compress specific data sets of quantum states, and classical compression algorithms cannot be used.
The parameters of the quantum autoencoder are trained using classical optimization algorithms.
We show an example of a simple programmable circuit, which can be trained as an efficient autoencoder.
We apply our model in the context of quantum simulation to compress the Hubbard model and the ground state of the Hamiltonian.
This algorithm is based on <a class="reference external" href="https://arxiv.org/pdf/1612.02806.pdf">Quantum autoencoders for efficient compression of quantum data</a> .</p>
<p><a class="reference external" href="../../../../../tutorials/QAE/QuantumAutoEncoder.md">QAE algorithm introduction</a> , <a class="reference external" href="../../../../examples/qae_test.py">QAE demo code</a></p>
<p>QAE quantum circuits：</p>
<figure class="align-default">
<img alt="../_images/QAE_Quantum_Cir.png" src="../_images/QAE_Quantum_Cir.png" />
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Quantum AutoEncoder demo</span>

<span class="sd">ref: ..\\..\\tutorials\QAE\\QuantumAutoEncoder.md</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">CategoricalCrossEntropy</span><span class="p">,</span> <span class="n">fidelityLoss</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim.adam</span> <span class="kn">import</span> <span class="n">Adam</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim.sgd</span> <span class="kn">import</span> <span class="n">SGD</span>
<span class="kn">from</span> <span class="nn">pyvqnet.data.data</span> <span class="kn">import</span> <span class="n">data_generator</span>

<span class="kn">from</span> <span class="nn">pyvqnet.qnn.qae.qae</span> <span class="kn">import</span> <span class="n">QAElayer</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">Loss</span>

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;TkAgg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<span class="c1">#define the model</span>
<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trash_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">total_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">7</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pqc</span> <span class="o">=</span> <span class="n">QAElayer</span><span class="p">(</span><span class="n">trash_num</span><span class="p">,</span> <span class="n">total_num</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pqc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1">#x = self.fc(x)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="c1">#load mnist dataset</span>
<span class="k">def</span> <span class="nf">load_mnist</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;training_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;..//..//data//MNIST_data&quot;</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">struct</span>
    <span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">pyarray</span>
    <span class="k">if</span> <span class="n">dataset</span> <span class="o">==</span> <span class="s2">&quot;training_data&quot;</span><span class="p">:</span>
        <span class="n">fname_image</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;train-images.idx3-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">fname_label</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;train-labels.idx1-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dataset</span> <span class="o">==</span> <span class="s2">&quot;testing_data&quot;</span><span class="p">:</span>
        <span class="n">fname_image</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;t10k-images.idx3-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">fname_label</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;t10k-labels.idx1-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dataset must be &#39;training_data&#39; or &#39;testing_data&#39;&quot;</span><span class="p">)</span>

    <span class="n">flbl</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_label</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
    <span class="n">magic_nr</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;II&quot;</span><span class="p">,</span> <span class="n">flbl</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>

    <span class="n">lbl</span> <span class="o">=</span> <span class="n">pyarray</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">flbl</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="n">flbl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">fimg</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_image</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
    <span class="n">magic_nr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;IIII&quot;</span><span class="p">,</span> <span class="n">fimg</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">pyarray</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">fimg</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="n">fimg</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">lbl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="n">digits</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
        <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">:</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lbl</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">def</span> <span class="nf">run2</span><span class="p">():</span>
    <span class="c1">##load dataset</span>
    <span class="c1">#x_train,x_test,y_train,y_test = load_mnist(&quot;training_data&quot;)</span>

    <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;training_data&quot;</span><span class="p">)</span>
    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;testing_data&quot;</span><span class="p">)</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">])</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">])</span>
    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="p">[:</span><span class="mi">100</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
    <span class="n">x_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="p">[</span><span class="n">x_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="p">[:</span><span class="mi">10</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="p">[</span><span class="n">x_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">encode_qubits</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">latent_qubits</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">trash_qubits</span> <span class="o">=</span> <span class="n">encode_qubits</span> <span class="o">-</span> <span class="n">latent_qubits</span>
    <span class="n">total_qubits</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">trash_qubits</span> <span class="o">+</span> <span class="n">encode_qubits</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;model start&quot;</span><span class="p">)</span>
    <span class="c1">#create model instance</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">trash_qubits</span><span class="p">,</span> <span class="n">total_qubits</span><span class="p">)</span>
    <span class="c1">#create optimizer</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.005</span><span class="p">)</span>

    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    <span class="n">F1</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;rlt.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="n">loss_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">loss_list_test</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fidelity_train</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fidelity_val</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">running_fidelity_train</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">running_fidelity_val</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;epoch </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
        <span class="n">full_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span><span class="mi">5</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">lr</span>  <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">lr</span> <span class="o">*</span><span class="mf">0.5</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> <span class="c1">#shuffle batch rather than data</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">encode_qubits</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">trash_qubits</span><span class="p">]),</span> <span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">np_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">floss</span> <span class="o">=</span> <span class="n">fidelityLoss</span><span class="p">()</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">floss</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="n">loss_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

            <span class="n">running_fidelity_train</span> <span class="o">+=</span> <span class="n">np_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>
            <span class="n">full_loss</span> <span class="o">+=</span> <span class="n">loss_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_loss</span> <span class="o">+=</span> <span class="n">batch_size</span>
            <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">correct</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="n">loss_output</span> <span class="o">=</span> <span class="n">full_loss</span> <span class="o">/</span> <span class="n">n_loss</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">, Loss: </span><span class="si">{</span><span class="n">loss_output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_output</span><span class="p">)</span>

        <span class="c1"># Evaluation</span>
        <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">full_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">encode_qubits</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">trash_qubits</span><span class="p">]),</span><span class="n">x</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">floss</span> <span class="o">=</span> <span class="n">fidelityLoss</span><span class="p">()</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">floss</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="n">loss_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">full_loss</span> <span class="o">+=</span> <span class="n">loss_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">running_fidelity_val</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">n_eval</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">n_loss</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">loss_output</span> <span class="o">=</span> <span class="n">full_loss</span> <span class="o">/</span> <span class="n">n_loss</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">, Loss: </span><span class="si">{</span><span class="n">loss_output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">loss_list_test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_output</span><span class="p">)</span>
        <span class="n">fidelity_train</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">running_fidelity_train</span> <span class="o">/</span> <span class="mi">64</span><span class="p">)</span>
        <span class="n">fidelity_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">running_fidelity_val</span> <span class="o">/</span> <span class="mi">64</span><span class="p">)</span>


    <span class="n">figure_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="s1">&#39;QAE-rate1.png&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">loss_list</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">loss_list_test</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;validation&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;QAE&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Epochs&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Loss&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">figure_path</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="n">F1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;done</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">F1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">model</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">run2</span><span class="p">()</span>
</pre></div>
</div>
<p>The QAE error value obtained by running the above code, the loss is 1/fidelity, tending to 1 means the fidelity is close to 1.</p>
<figure class="align-default">
<img alt="../_images/qae_train_loss.png" src="../_images/qae_train_loss.png" />
</figure>
</section>
</section>
<section id="quantum-circuits-structure-learning-demo">
<h2>Quantum Circuits Structure Learning Demo<a class="headerlink" href="#quantum-circuits-structure-learning-demo" title="Permalink to this headline">¶</a></h2>
<section id="quantum-circuits-structure-learning">
<h3>1.Quantum circuits structure learning<a class="headerlink" href="#quantum-circuits-structure-learning" title="Permalink to this headline">¶</a></h3>
<p>In the quantum circuit structure, the most frequently used quantum gates with parameters are <cite>RZ</cite> ,  <cite>RY</cite> , and  <cite>RX</cite>  gates, but which gate to use under what circumstances is a question worth studying. One method is random selection, but in this case It is very likely that the best results will not be achieved.
The core goal of Quantum circuit structure learning task is to find the optimal combination of quantum gates with parameters.
The approach here is that this set of optimal quantum logic gates should make the loss function to be the minimum.</p>
<p><a class="reference external" href="../../../../../tutorials/QCSL/QCSL_demo.md">QCSL algorithm introduction</a> , <a class="reference external" href="../../../../examples/qcsl_test.py">QCSL demo code</a> .</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Quantum Circuits Strcture Learning Demo</span>

<span class="sd">ref: ..\\..\\tutorials\QCSL\\QCSL demo.md</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">pyqpanda</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">from</span> <span class="nn">pyvqnet.tensor.tensor</span> <span class="kn">import</span> <span class="n">QTensor</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyvqnet._core</span> <span class="kn">import</span> <span class="n">Tensor</span> <span class="k">as</span> <span class="n">CoreTensor</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">pyvqnet.qnn.measure</span> <span class="kn">import</span> <span class="n">expval</span>
<span class="n">machine</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">CPUQVM</span><span class="p">()</span>
<span class="n">machine</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>
<span class="n">nqbits</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1">#genearate candidate quantum gates</span>
<span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">param</span><span class="p">:</span><span class="n">CoreTensor</span><span class="p">,</span><span class="n">generators</span><span class="p">,</span><span class="n">qbits</span><span class="p">,</span><span class="n">circuit</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">generators</span> <span class="o">==</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RX</span><span class="p">(</span><span class="n">qbits</span><span class="p">,</span><span class="n">param</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">generators</span> <span class="o">==</span><span class="s2">&quot;Y&quot;</span><span class="p">:</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">qbits</span><span class="p">,</span><span class="n">param</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RZ</span><span class="p">(</span><span class="n">qbits</span><span class="p">,</span><span class="n">param</span><span class="p">))</span>

<span class="c1">#generate circuits based on candidate quantum gates</span>
<span class="k">def</span> <span class="nf">circuits</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">generators</span><span class="p">,</span><span class="n">circuit</span><span class="p">):</span>
    <span class="n">gen</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">generators</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nqbits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">circuit</span><span class="p">)</span>
    <span class="n">gen</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">generators</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nqbits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">circuit</span><span class="p">)</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">nqbits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nqbits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
    <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">prog</span>

<span class="k">def</span> <span class="nf">ansatz1</span><span class="p">(</span><span class="n">params</span><span class="p">:</span><span class="n">QTensor</span><span class="p">,</span><span class="n">generators</span><span class="p">):</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getdata</span><span class="p">()</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">circuits</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">generators</span><span class="p">,</span><span class="n">circuit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expval</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span><span class="n">prog</span><span class="p">,{</span><span class="s2">&quot;Z0&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span><span class="n">nqbits</span><span class="p">),</span> <span class="n">expval</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span><span class="n">prog</span><span class="p">,{</span><span class="s2">&quot;Y1&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span><span class="n">nqbits</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ansatz2</span><span class="p">(</span><span class="n">params</span><span class="p">:</span><span class="n">QTensor</span><span class="p">,</span><span class="n">generators</span><span class="p">):</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getdata</span><span class="p">()</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">circuits</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">circuit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expval</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span><span class="n">prog</span><span class="p">,{</span><span class="s2">&quot;X0&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span><span class="n">nqbits</span><span class="p">)</span>

<span class="c1">#target loss function</span>
<span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">generators</span><span class="p">):</span>
    <span class="n">Z</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">ansatz1</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">generators</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">ansatz2</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">generators</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">Y</span> <span class="o">+</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">Z</span> <span class="o">-</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">X</span>

<span class="c1">#rotosolve algorithm to find optimal parameter</span>
<span class="k">def</span> <span class="nf">rotosolve</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">M_0</span><span class="p">):</span>  <span class="c1"># M_0 only calculated once</span>
    <span class="n">params</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">M_0_plus</span> <span class="o">=</span> <span class="n">cost</span><span class="p">(</span><span class="n">QTensor</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="n">generators</span><span class="p">)</span>
    <span class="n">params</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">M_0_minus</span> <span class="o">=</span> <span class="n">cost</span><span class="p">(</span><span class="n">QTensor</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="n">generators</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
        <span class="mf">2.0</span> <span class="o">*</span> <span class="n">M_0</span> <span class="o">-</span> <span class="n">M_0_plus</span> <span class="o">-</span> <span class="n">M_0_minus</span><span class="p">,</span> <span class="n">M_0_plus</span> <span class="o">-</span> <span class="n">M_0_minus</span>
    <span class="p">)</span>  <span class="c1"># returns value in (-pi,pi]</span>
    <span class="n">params</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">params</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">cost</span><span class="p">(</span><span class="n">QTensor</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="n">generators</span><span class="p">)</span>

<span class="c1">#rotoselect algorithm to find best circuits structure</span>
<span class="k">def</span> <span class="nf">optimal_theta_and_gen_helper</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="n">generators</span><span class="p">):</span>
    <span class="n">params</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">M_0</span> <span class="o">=</span> <span class="n">loss</span><span class="p">(</span><span class="n">QTensor</span><span class="p">(</span><span class="n">params</span><span class="p">),</span><span class="n">generators</span><span class="p">)</span><span class="c1">#init value</span>
    <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="s2">&quot;Z&quot;</span><span class="p">]:</span>
        <span class="n">generators</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind</span>
        <span class="n">params_cost</span> <span class="o">=</span> <span class="n">rotosolve</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="n">M_0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;X&quot;</span> <span class="ow">or</span> <span class="n">params_cost</span> <span class="o">&lt;=</span> <span class="n">params_opt_cost</span><span class="p">:</span>
            <span class="n">params_opt_d</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">params_opt_cost</span> <span class="o">=</span> <span class="n">params_cost</span>
            <span class="n">generators_opt_d</span> <span class="o">=</span> <span class="n">kind</span>
    <span class="k">return</span> <span class="n">params_opt_d</span><span class="p">,</span> <span class="n">generators_opt_d</span>

<span class="k">def</span> <span class="nf">rotoselect_cycle</span><span class="p">(</span><span class="n">params</span><span class="p">:</span><span class="n">np</span><span class="p">,</span><span class="n">generators</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">params</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">generators</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimal_theta_and_gen_helper</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="n">generators</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">,</span><span class="n">generators</span>


<span class="n">params</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.25</span><span class="p">]))</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getdata</span><span class="p">()</span>
<span class="n">generator</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span>
<span class="n">generators</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
<span class="n">epoch</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">state_save</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epoch</span><span class="p">):</span>
    <span class="n">state_save</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">(</span><span class="n">QTensor</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="n">generators</span><span class="p">))</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">generators</span> <span class="o">=</span> <span class="n">rotoselect_cycle</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">generators</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimal generators are: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">generators</span><span class="p">))</span>
<span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">epoch</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;TkAgg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">state_save</span><span class="p">,</span> <span class="s2">&quot;o-&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;rotoselect&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;cycles&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;cost&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">0.80</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The quantum circuit structure obtained by running the above code contains <span class="math notranslate nohighlight">\(RX\)</span>, one <span class="math notranslate nohighlight">\(RY\)</span></p>
<figure class="align-default">
<img alt="../_images/final_quantum_circuit.png" src="../_images/final_quantum_circuit.png" />
</figure>
<p>And with the parameters in the quantum gate: math:<cite>theta_1</cite>, <span class="math notranslate nohighlight">\(\theta_2\)</span> change,Loss function has different values.</p>
<figure class="align-default">
<img alt="../_images/loss3d.png" src="../_images/loss3d.png" />
</figure>
</section>
</section>
<section id="hybird-quantum-classic-nerual-network-demo">
<h2>Hybird Quantum Classic Nerual Network Demo<a class="headerlink" href="#hybird-quantum-classic-nerual-network-demo" title="Permalink to this headline">¶</a></h2>
<section id="hybrid-quantum-classic-neural-network-model">
<h3>1.Hybrid Quantum Classic Neural Network Model<a class="headerlink" href="#hybrid-quantum-classic-neural-network-model" title="Permalink to this headline">¶</a></h3>
<p>Machine learning (ML) has become a successful interdisciplinary field that aims to extract generalizable information from data mathematically.
Quantum machine learning seeks to use the principles of quantum mechanics to enhance machine learning, and vice versa.
Whether your goal is to enhance classical ML algorithms by outsourcing difficult calculations to quantum computers,
or use classical ML architectures to optimize quantum algorithms-both fall into the category of quantum machine learning (QML).
In this chapter, we will explore how to partially quantify classical neural networks to create hybrid quantum classical neural networks.
Quantum circuits are composed of quantum logic gates, and the quantum calculations implemented by
these logic gates are proved to be differentiable by the paper <a class="reference external" href="https://arxiv.org/abs/1803.00745">Quantum Circuit Learning</a>.
Therefore, researchers try to put quantum circuits and classical neural network modules together for training on hybrid quantum classical machine learning tasks.
We will write a simple example to implement a neural network model training task using VQNet.
The purpose of this example is to demonstrate the simplicity of VQNet and encourage ML practitioners to explore the possibilities of quantum computing.</p>
<p><a class="reference external" href="../../../../../tutorials/HQCNN/HQCNN_demo.md">HQCNN algorithm introduction</a> ,  <a class="reference external" href="../../../../examples/hqcnn_test.py">HQCNN demo code</a></p>
<section id="data-preparation">
<h4>Data Preparation<a class="headerlink" href="#data-preparation" title="Permalink to this headline">¶</a></h4>
<p>We will use <a class="reference external" href="http://yann.lecun.com/exdb/mnist/">MNIST datasets</a>, the most basic neural network handwritten digit database as the classification data.
We first load MNIST and filter data samples containing 0 and 1. These samples are divided into training data training_data and testing data testing_data, each of which has a dimension of 1*784.</p>
<figure class="align-default">
<img alt="../_images/mnsit_data_examples.png" src="../_images/mnsit_data_examples.png" />
</figure>
</section>
<section id="construct-quantum-circuits">
<h4>Construct Quantum Circuits<a class="headerlink" href="#construct-quantum-circuits" title="Permalink to this headline">¶</a></h4>
<p>In this example, we use the source quantum <a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/">pyQPanda</a> , A simple quantum circuit of 1 qubit is defined. The circuit takes the output of the classical neural network layer as input,encodes quantum data through <code class="docutils literal notranslate"><span class="pre">H</span></code> , <code class="docutils literal notranslate"><span class="pre">RY</span></code>  quantum logic gates, and calculates the expected value of Hamiltonian in the z direction As output.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">pyqpanda</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1">#Use pyQPanda to create a simulator</span>
    <span class="n">machine</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">CPUQVM</span><span class="p">()</span>
    <span class="n">machine</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>
    <span class="c1">#Use pyQPanda to alloc qubits</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
    <span class="c1">#Use pyQPanda to alloc classic bits</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
    <span class="c1">#Construct circuits</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="c1">#Construct quantum program</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
    <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="c1">#Defines measurement</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">measure_all</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">cbits</span><span class="p">)</span>

    <span class="c1">#run quantum with quantum measurements</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">cbits</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

    <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="mi">100</span>
    <span class="n">expectation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">states</span> <span class="o">*</span> <span class="n">probabilities</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expectation</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../_images/hqcnn_quantum_cir.png" src="../_images/hqcnn_quantum_cir.png" />
</figure>
</section>
<section id="create-hybird-model">
<h4>Create Hybird Model<a class="headerlink" href="#create-hybird-model" title="Permalink to this headline">¶</a></h4>
<p>Since quantum circuits can perform automatic differentiation calculations together with classical neural networks,
Therefore, we can use VQNet’s 2-dimensional convolutional layer <code class="docutils literal notranslate"><span class="pre">Conv2D</span></code> , the pooling layer <code class="docutils literal notranslate"><span class="pre">MaxPool2D</span></code> , the fully connected layer <code class="docutils literal notranslate"><span class="pre">Linear</span></code> and
the quantum circuit circuit built model just now.
Through the definition of the Net and Hybrid classes inherited from the VQNet automatic differentiation module <code class="docutils literal notranslate"><span class="pre">Module</span></code>
in the following code, and the definition of the forward calculation of the data in the model forward function <code class="docutils literal notranslate"><span class="pre">forward()</span></code>,
we have constructed an automatic differentiation Model of
Convolution, dimensionality reduction, quantum coding, and measurement of the MNIST data in this example are performed to obtain the final features required for the classification task.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#Quantum computing layer front pass and the definition of gradient calculation function, which need to be inherited from the abstract class Module</span>
<span class="k">class</span> <span class="nc">Hybrid</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Hybrid quantum - Quantum layer definition &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Hybrid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="n">expectation_z</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="n">expectation_z</span><span class="p">]]</span>
        <span class="n">requires_grad</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">requires_grad</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">QTensor</span><span class="o">.</span><span class="n">NO_GRAD</span>
        <span class="k">def</span> <span class="nf">_backward</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Backward pass computation &quot;&quot;&quot;</span>
            <span class="n">input_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">shift_right</span> <span class="o">=</span> <span class="n">input_list</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">input_list</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span>
            <span class="n">shift_left</span> <span class="o">=</span> <span class="n">input_list</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">input_list</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span>

            <span class="n">gradients</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_list</span><span class="p">)):</span>
                <span class="n">expectation_right</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">shift_right</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">expectation_left</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">shift_left</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="n">gradient</span> <span class="o">=</span> <span class="n">expectation_right</span> <span class="o">-</span> <span class="n">expectation_left</span>
                <span class="n">gradients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span>
            <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">gradients</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="n">gradients</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">QTensor</span><span class="o">.</span><span class="n">GraphNode</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="nb">input</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">_backward</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">input</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="n">requires_grad</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>

<span class="c1">#Model definition</span>
<span class="k">class</span> <span class="nc">Net</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Net</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxpool1</span> <span class="o">=</span> <span class="n">MaxPool2D</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxpool2</span> <span class="o">=</span> <span class="n">MaxPool2D</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hybrid</span> <span class="o">=</span> <span class="n">Hybrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc3</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c1"># 1 6 24 24</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxpool1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c1"># 1 16 8 8</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxpool2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># 1 256</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c1"># 1 64</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>    <span class="c1"># 1 1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hybrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../_images/hqcnnmodel.PNG" src="../_images/hqcnnmodel.PNG" />
</figure>
</section>
<section id="training-and-testing">
<h4>Training and testing<a class="headerlink" href="#training-and-testing" title="Permalink to this headline">¶</a></h4>
<p>Through the above code example, we have defined the model. Similar to the classic neural network model training, what we need to do is to instantiate the model, define the loss function and optimizer, and define the entire training and testing process.
For the hybrid neural network model as shown in the figure below, we calculate the loss value forward by looping the input data,
and automatically calculate the gradient of each parameter to be trained in the backward calculation, and use the optimizer to optimize the parameters until the number of iterations meets the preset Set value.</p>
<figure class="align-default">
<img alt="../_images/hqcnnarch.PNG" src="../_images/hqcnnarch.PNG" />
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#Create a model</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Net</span><span class="p">()</span>
<span class="c1">#Use adam optimizer</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.005</span><span class="p">)</span>
<span class="c1">#Use cross entropy loss</span>
<span class="n">loss_func</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>

<span class="c1">#train epoches</span>
<span class="n">epochs</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">train_loss_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">val_loss_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">train_acc_list</span> <span class="o">=</span><span class="p">[]</span>
<span class="n">val_acc_list</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
    <span class="n">total_loss</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_train</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>

        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="n">loss_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">correct</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
        <span class="n">n_train</span> <span class="o">+=</span> <span class="n">batch_size</span>

        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>

        <span class="n">total_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_np</span><span class="p">)</span>

    <span class="n">train_loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">total_loss</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_loss</span><span class="p">))</span>
    <span class="n">train_acc_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">correct</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_train</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.0f}</span><span class="s2"> loss is : </span><span class="si">{:.10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">train_loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>


    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="n">loss_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">correct</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
        <span class="n">n_eval</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">total_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_np</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Eval Accuracy: </span><span class="si">{</span><span class="n">correct</span> <span class="o">/</span> <span class="n">n_eval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">val_loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">total_loss</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_loss</span><span class="p">))</span>
    <span class="n">val_acc_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">correct</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_eval</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="visualization">
<h4>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h4>
<p>The visualization curve of data loss function and accuracy on training and test data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">xrange</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">train_loss_list</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">figure_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="s1">&#39;HQCNN LOSS.png&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xrange</span><span class="p">,</span><span class="n">train_loss_list</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xrange</span><span class="p">,</span><span class="n">val_loss_list</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;validation&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;HQCNN&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Epochs&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Loss&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">epochs</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">step</span> <span class="o">=</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">figure_path</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">figure_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="s1">&#39;HQCNN Accuracy.png&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xrange</span><span class="p">,</span><span class="n">train_acc_list</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xrange</span><span class="p">,</span><span class="n">val_acc_list</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;validation&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;HQCNN&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Epochs&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Accuracy&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">epochs</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">step</span> <span class="o">=</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower right&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">figure_path</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../_images/HQCNNLOSS.png" src="../_images/HQCNNLOSS.png" />
</figure>
<figure class="align-default">
<img alt="../_images/HQCNNAccuracy.png" src="../_images/HQCNNAccuracy.png" />
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n_samples_show</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="n">n_samples_show</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">n_samples_show</span><span class="p">:</span>
        <span class="k">break</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">QTensor</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Predicted </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../_images/eval_test.png" src="../_images/eval_test.png" />
</figure>
</section>
</section>
<section id="hybrid-quantum-classical-transfer-learning-model">
<h3>2.Hybrid quantum classical transfer learning model<a class="headerlink" href="#hybrid-quantum-classical-transfer-learning-model" title="Permalink to this headline">¶</a></h3>
<p>We apply a machine learning method called transfer learning to image classifier based on hybrid classical quantum
network. We will write a simple example of integrating Pyqpanda with VQNet.</p>
<p>Transfer learning is a mature artificial neural network training technology. It is based on general intuition,
that is, if the pre trained network is good at solving a given problem, it can also be used to solve a different
but related problem with only some additional training.</p>
<p><a class="reference external" href="../../../../../tutorials/QTransferLearning/QTransferLearning_demo.md">QTransferLearning Introduction to algorithm documents</a>    VQNet Sample code：<a class="reference external" href="../../../../examples/qcnn_TransferLearning_test.py">QTransferLearning</a> .</p>
<blockquote>
<div><p>Quantum partial circuit diagram</p>
</div></blockquote>
<figure class="align-default">
<img alt="../_images/QTransferLearning_cir.png" src="../_images/QTransferLearning_cir.png" />
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Quantum Classic Nerual Network Transfer Learning demo</span>

<span class="sd">ref: ..\\..\\tutorials\\QTransferLearning\\QTransferLearning_demo.md</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pyvqnet</span>
<span class="kn">from</span> <span class="nn">pyvqnet.data</span> <span class="kn">import</span> <span class="n">mnist</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.linear</span> <span class="kn">import</span> <span class="n">Linear</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.conv</span> <span class="kn">import</span> <span class="n">Conv2D</span>
<span class="kn">from</span> <span class="nn">pyvqnet.utils.storage</span> <span class="kn">import</span> <span class="n">load_parameters</span><span class="p">,</span> <span class="n">save_parameters</span>

<span class="kn">from</span> <span class="nn">pyvqnet.nn</span> <span class="kn">import</span> <span class="n">activation</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.pooling</span> <span class="kn">import</span> <span class="n">MaxPool2D</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.dropout</span> <span class="kn">import</span> <span class="n">Dropout</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.batch_norm</span> <span class="kn">import</span> <span class="n">BatchNorm2d</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">SoftmaxCrossEntropy</span>

<span class="kn">from</span> <span class="nn">pyvqnet.optim.sgd</span> <span class="kn">import</span> <span class="n">SGD</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim.adam</span> <span class="kn">import</span> <span class="n">Adam</span>
<span class="kn">from</span> <span class="nn">pyvqnet.data.data</span> <span class="kn">import</span> <span class="n">data_generator</span>
<span class="kn">from</span> <span class="nn">pyvqnet.tensor</span> <span class="kn">import</span> <span class="n">tensor</span>
<span class="kn">from</span> <span class="nn">pyvqnet.tensor.tensor</span> <span class="kn">import</span> <span class="n">QTensor</span>
<span class="kn">import</span> <span class="nn">pyqpanda</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyvqnet.utils.initializer</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyvqnet.utils</span> <span class="kn">import</span> <span class="n">initializer</span>
<span class="kn">from</span> <span class="nn">pyvqnet.qnn.quantumlayer</span> <span class="kn">import</span> <span class="n">QuantumLayer</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;TkAgg&#39;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">IF_PLOT</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;./result&quot;</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="s2">&quot;./result&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="c1"># classical CNN</span>
<span class="k">class</span> <span class="nc">CNN</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CNN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d1</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d2</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu2</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxpool2</span> <span class="o">=</span> <span class="n">MaxPool2D</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conv3</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d3</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu3</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conv4</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d4</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu4</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxpool4</span> <span class="o">=</span> <span class="n">MaxPool2D</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">128</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc3</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Relu1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxpool2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Relu2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Relu3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv3</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxpool4</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Relu4</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv4</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">load_mnist</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;training_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;..//..//data//MNIST_data&quot;</span><span class="p">):</span>  <span class="c1"># load data</span>
    <span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">struct</span>
    <span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">pyarray</span>
    <span class="k">if</span> <span class="n">dataset</span> <span class="o">==</span> <span class="s2">&quot;training_data&quot;</span><span class="p">:</span>
        <span class="n">fname_image</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;train-images.idx3-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">fname_label</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;train-labels.idx1-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dataset</span> <span class="o">==</span> <span class="s2">&quot;testing_data&quot;</span><span class="p">:</span>
        <span class="n">fname_image</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;t10k-images.idx3-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">fname_label</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;t10k-labels.idx1-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dataset must be &#39;training_data&#39; or &#39;testing_data&#39;&quot;</span><span class="p">)</span>

    <span class="n">flbl</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_label</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
    <span class="n">magic_nr</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;II&quot;</span><span class="p">,</span> <span class="n">flbl</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
    <span class="n">lbl</span> <span class="o">=</span> <span class="n">pyarray</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">flbl</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="n">flbl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">fimg</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_image</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
    <span class="n">magic_nr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;IIII&quot;</span><span class="p">,</span> <span class="n">fimg</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">pyarray</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">fimg</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    <span class="n">fimg</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">lbl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="n">digits</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
        <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">:</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lbl</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">def</span> <span class="nf">data_select</span><span class="p">(</span><span class="n">train_num</span><span class="p">,</span> <span class="n">test_num</span><span class="p">):</span>
    <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;training_data&quot;</span><span class="p">)</span>  <span class="c1"># load train data</span>
    <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;testing_data&quot;</span><span class="p">)</span>

    <span class="c1"># Train Leaving only labels 0 and 1</span>
    <span class="n">idx_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_train</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">train_num</span><span class="p">],</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_train</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">train_num</span><span class="p">])</span>

    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="p">[</span><span class="n">idx_train</span><span class="p">]</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="n">idx_train</span><span class="p">]</span>

    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">y_train</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Test Leaving only labels 0 and 1</span>
    <span class="n">idx_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_test</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">test_num</span><span class="p">],</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_test</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">test_num</span><span class="p">])</span>

    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="p">[</span><span class="n">idx_test</span><span class="p">]</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="p">[</span><span class="n">idx_test</span><span class="p">]</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">y_test</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">to get cnn model parameters for transfer learning</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">train_size</span> <span class="o">=</span><span class="mi">50</span>
<span class="n">eval_size</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">EPOCHES</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">def</span> <span class="nf">classcal_cnn_model_making</span><span class="p">():</span>
    <span class="c1"># load train data</span>
    <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;training_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;testing_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="p">[:</span><span class="n">train_size</span><span class="p">]</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[:</span><span class="n">train_size</span><span class="p">]</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="p">[:</span><span class="n">eval_size</span><span class="p">]</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="p">[:</span><span class="n">eval_size</span><span class="p">]</span>

    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">10</span><span class="p">)[</span><span class="n">y_train</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">10</span><span class="p">)[</span><span class="n">y_test</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">CNN</span><span class="p">()</span>

    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.005</span><span class="p">)</span>
    <span class="n">loss_func</span> <span class="o">=</span> <span class="n">SoftmaxCrossEntropy</span><span class="p">()</span>

    <span class="n">epochs</span> <span class="o">=</span> <span class="n">EPOCHES</span>
    <span class="n">loss_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>

    <span class="n">SAVE_FLAG</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">temp_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
        <span class="n">total_loss</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="c1"># Forward pass</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="c1"># Calculating loss</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>  <span class="c1"># target output</span>
            <span class="n">loss_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># Backward pass</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
            <span class="c1"># Optimize the weights</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>

            <span class="n">total_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_np</span><span class="p">)</span>

        <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">total_loss</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_loss</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.0f}</span><span class="s2"> loss is : </span><span class="si">{:.10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">SAVE_FLAG</span><span class="p">:</span>
            <span class="n">temp_loss</span> <span class="o">=</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">save_parameters</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s2">&quot;./result/QCNN_TL_1.model&quot;</span><span class="p">)</span>
            <span class="n">SAVE_FLAG</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">temp_loss</span> <span class="o">&gt;</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">temp_loss</span> <span class="o">=</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">save_parameters</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s2">&quot;./result/QCNN_TL_1.model&quot;</span><span class="p">)</span>

    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">correct</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
        <span class="n">n_eval</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Eval Accuracy: </span><span class="si">{</span><span class="n">correct</span> <span class="o">/</span> <span class="n">n_eval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">n_samples_show</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="n">n_samples_show</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">n_samples_show</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">QTensor</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Predicted </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">classical_cnn_TransferLearning_predict</span><span class="p">():</span>
    <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;testing_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="p">[:</span><span class="n">eval_size</span><span class="p">]</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="p">[:</span><span class="n">eval_size</span><span class="p">]</span>

    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">10</span><span class="p">)[</span><span class="n">y_test</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">CNN</span><span class="p">()</span>

    <span class="n">model_parameter</span> <span class="o">=</span> <span class="n">load_parameters</span><span class="p">(</span><span class="s2">&quot;./result/QCNN_TL_1.model&quot;</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">model_parameter</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">correct</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
        <span class="n">n_eval</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Eval Accuracy: </span><span class="si">{</span><span class="n">correct</span> <span class="o">/</span> <span class="n">n_eval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">n_samples_show</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="n">n_samples_show</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">n_samples_show</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">QTensor</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Predicted </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">quantum_cnn_TransferLearning</span><span class="p">():</span>

    <span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># Number of qubits</span>
    <span class="n">q_depth</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Depth of the quantum circuit (number of variational layers)</span>

    <span class="k">def</span> <span class="nf">Q_H_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">nqubits</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Layer of single-qubit Hadamard gates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nqubits</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">circuit</span>

    <span class="k">def</span> <span class="nf">Q_RY_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Layer of parametrized qubit rotations around the y axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">element</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">circuit</span>

    <span class="k">def</span> <span class="nf">Q_entangling_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">nqubits</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Layer of CNOTs followed by another shifted layer of CNOT.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In other words it should apply something like :</span>
        <span class="c1"># CNOT  CNOT  CNOT  CNOT...  CNOT</span>
        <span class="c1">#   CNOT  CNOT  CNOT...  CNOT</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nqubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>  <span class="c1"># Loop over even indices: i=0,2,...N-2</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nqubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>  <span class="c1"># Loop over odd indices:  i=1,3,...N-3</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">circuit</span>

    <span class="k">def</span> <span class="nf">Q_quantum_net</span><span class="p">(</span><span class="n">q_input_features</span><span class="p">,</span> <span class="n">q_weights_flat</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="n">cubits</span><span class="p">,</span> <span class="n">machine</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The variational quantum circuit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">machine</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">CPUQVM</span><span class="p">()</span>
        <span class="n">machine</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>
        <span class="n">qubits</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>

        <span class="c1"># Reshape weights</span>
        <span class="n">q_weights</span> <span class="o">=</span> <span class="n">q_weights_flat</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">q_depth</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">])</span>

        <span class="c1"># Start from state |+&gt; , unbiased w.r.t. |0&gt; and |1&gt;</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Q_H_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">))</span>

        <span class="c1"># Embed features in the quantum node</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Q_RY_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">q_input_features</span><span class="p">))</span>

        <span class="c1"># Sequence of trainable variational layers</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q_depth</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Q_entangling_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">))</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Q_RY_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">q_weights</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>

        <span class="c1"># Expectation values in the Z basis</span>
        <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>

        <span class="n">exp_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
            <span class="n">pauli_str</span> <span class="o">=</span> <span class="s2">&quot;Z&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
            <span class="n">pauli_map</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">PauliOperator</span><span class="p">(</span><span class="n">pauli_str</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">hamiltion</span> <span class="o">=</span> <span class="n">pauli_map</span><span class="o">.</span><span class="n">toHamiltonian</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">get_expectation</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">hamiltion</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>
            <span class="n">exp_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">exp_vals</span>

    <span class="k">class</span> <span class="nc">Q_DressedQuantumNet</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Definition of the *dressed* layout.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pre_net</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">post_net</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">temp_Q</span> <span class="o">=</span> <span class="n">QuantumLayer</span><span class="p">(</span><span class="n">Q_quantum_net</span><span class="p">,</span> <span class="n">q_depth</span> <span class="o">*</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_features</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Defining how tensors are supposed to move through the *dressed* quantum</span>
<span class="sd">            net.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># obtain the input features for the quantum circuit</span>
            <span class="c1"># by reducing the feature dimension from 512 to 4</span>
            <span class="n">pre_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_net</span><span class="p">(</span><span class="n">input_features</span><span class="p">)</span>
            <span class="n">q_in</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">pre_out</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">q_out_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp_Q</span><span class="p">(</span><span class="n">q_in</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">q_out_elem</span>
            <span class="c1"># return the two-dimensional prediction from the postprocessing layer</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_net</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


    <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;training_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>  <span class="c1"># load train data</span>
    <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;testing_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="p">[:</span><span class="n">train_size</span><span class="p">]</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[:</span><span class="n">train_size</span><span class="p">]</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="p">[:</span><span class="n">eval_size</span><span class="p">]</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="p">[:</span><span class="n">eval_size</span><span class="p">]</span>

    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">10</span><span class="p">)[</span><span class="n">y_train</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">10</span><span class="p">)[</span><span class="n">y_test</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">CNN</span><span class="p">()</span>
    <span class="n">model_param</span> <span class="o">=</span> <span class="n">load_parameters</span><span class="p">(</span><span class="s2">&quot;./result/QCNN_TL_1.model&quot;</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">model_param</span><span class="p">)</span>

    <span class="n">loss_func</span> <span class="o">=</span> <span class="n">SoftmaxCrossEntropy</span><span class="p">()</span>

    <span class="n">epochs</span> <span class="o">=</span> <span class="n">EPOCHES</span>
    <span class="n">loss_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">eval_losses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">model_hybrid</span> <span class="o">=</span> <span class="n">model</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">model_hybrid</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model_hybrid</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
        <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">model_hybrid</span><span class="o">.</span><span class="n">fc3</span> <span class="o">=</span> <span class="n">Q_DressedQuantumNet</span><span class="p">()</span>
    <span class="n">optimizer_hybrid</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model_hybrid</span><span class="o">.</span><span class="n">fc3</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
    <span class="n">model_hybrid</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>

    <span class="n">SAVE_FLAG</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">temp_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
        <span class="n">total_loss</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
            <span class="n">optimizer_hybrid</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="c1"># Forward pass</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">model_hybrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>  <span class="c1"># target output</span>
            <span class="n">loss_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># Backward pass</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
            <span class="c1"># Optimize the weights</span>
            <span class="n">optimizer_hybrid</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>
            <span class="n">total_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_np</span><span class="p">)</span>

        <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">total_loss</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_loss</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.0f}</span><span class="s2"> loss is : </span><span class="si">{:.10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">SAVE_FLAG</span><span class="p">:</span>
            <span class="n">temp_loss</span> <span class="o">=</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">save_parameters</span><span class="p">(</span><span class="n">model_hybrid</span><span class="o">.</span><span class="n">fc3</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s2">&quot;./result/QCNN_TL_FC3.model&quot;</span><span class="p">)</span>
            <span class="n">save_parameters</span><span class="p">(</span><span class="n">model_hybrid</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s2">&quot;./result/QCNN_TL_ALL.model&quot;</span><span class="p">)</span>
            <span class="n">SAVE_FLAG</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">temp_loss</span> <span class="o">&gt;</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">temp_loss</span> <span class="o">=</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">save_parameters</span><span class="p">(</span><span class="n">model_hybrid</span><span class="o">.</span><span class="n">fc3</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s2">&quot;./result/QCNN_TL_FC3.model&quot;</span><span class="p">)</span>
                <span class="n">save_parameters</span><span class="p">(</span><span class="n">model_hybrid</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s2">&quot;./result/QCNN_TL_ALL.model&quot;</span><span class="p">)</span>

        <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">loss_temp</span> <span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">model_hybrid</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
            <span class="n">np_loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y1</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">correct</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
            <span class="n">n_eval</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">loss_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np_loss</span><span class="p">)</span>
        <span class="n">eval_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">loss_temp</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_eval</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.0f}</span><span class="s2"> eval loss is : </span><span class="si">{:.10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">eval_losses</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;model loss&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">loss_list</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;train_losses&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">eval_losses</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;eval_losses&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;loss&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s2">&quot;train_losses&quot;</span><span class="p">,</span> <span class="s2">&quot;eval_losses&quot;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;qcnn_transfer_learning_classical&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">n_samples_show</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="n">n_samples_show</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">model_hybrid</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">n_samples_show</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model_hybrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">QTensor</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Predicted </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">quantum_cnn_TransferLearning_predict</span><span class="p">():</span>

    <span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># Number of qubits</span>
    <span class="n">q_depth</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Depth of the quantum circuit (number of variational layers)</span>

    <span class="k">def</span> <span class="nf">Q_H_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">nqubits</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Layer of single-qubit Hadamard gates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nqubits</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">circuit</span>

    <span class="k">def</span> <span class="nf">Q_RY_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Layer of parametrized qubit rotations around the y axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">element</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">circuit</span>

    <span class="k">def</span> <span class="nf">Q_entangling_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">nqubits</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Layer of CNOTs followed by another shifted layer of CNOT.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In other words it should apply something like :</span>
        <span class="c1"># CNOT  CNOT  CNOT  CNOT...  CNOT</span>
        <span class="c1">#   CNOT  CNOT  CNOT...  CNOT</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nqubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>  <span class="c1"># Loop over even indices: i=0,2,...N-2</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nqubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>  <span class="c1"># Loop over odd indices:  i=1,3,...N-3</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">circuit</span>

    <span class="k">def</span> <span class="nf">Q_quantum_net</span><span class="p">(</span><span class="n">q_input_features</span><span class="p">,</span> <span class="n">q_weights_flat</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="n">cubits</span><span class="p">,</span> <span class="n">machine</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The variational quantum circuit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">machine</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">CPUQVM</span><span class="p">()</span>
        <span class="n">machine</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>
        <span class="n">qubits</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>

        <span class="c1"># Reshape weights</span>
        <span class="n">q_weights</span> <span class="o">=</span> <span class="n">q_weights_flat</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">q_depth</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">])</span>

        <span class="c1"># Start from state |+&gt; , unbiased w.r.t. |0&gt; and |1&gt;</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Q_H_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">))</span>

        <span class="c1"># Embed features in the quantum node</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Q_RY_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">q_input_features</span><span class="p">))</span>

        <span class="c1"># Sequence of trainable variational layers</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q_depth</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Q_entangling_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">))</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Q_RY_layer</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">q_weights</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>

        <span class="c1"># Expectation values in the Z basis</span>
        <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
        <span class="n">exp_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
            <span class="n">pauli_str</span> <span class="o">=</span> <span class="s2">&quot;Z&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
            <span class="n">pauli_map</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">PauliOperator</span><span class="p">(</span><span class="n">pauli_str</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">hamiltion</span> <span class="o">=</span> <span class="n">pauli_map</span><span class="o">.</span><span class="n">toHamiltonian</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">get_expectation</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">hamiltion</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>
            <span class="n">exp_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">exp_vals</span>

    <span class="k">class</span> <span class="nc">Q_DressedQuantumNet</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Definition of the *dressed* layout.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pre_net</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">post_net</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">temp_Q</span> <span class="o">=</span> <span class="n">QuantumLayer</span><span class="p">(</span><span class="n">Q_quantum_net</span><span class="p">,</span> <span class="n">q_depth</span> <span class="o">*</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_features</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Defining how tensors are supposed to move through the *dressed* quantum</span>
<span class="sd">            net.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># obtain the input features for the quantum circuit</span>
            <span class="c1"># by reducing the feature dimension from 512 to 4</span>
            <span class="n">pre_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_net</span><span class="p">(</span><span class="n">input_features</span><span class="p">)</span>
            <span class="n">q_in</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">pre_out</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">q_out_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">temp_Q</span><span class="p">(</span><span class="n">q_in</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">q_out_elem</span>
            <span class="c1"># return the two-dimensional prediction from the postprocessing layer</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_net</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


    <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;training_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>  <span class="c1"># load train data</span>
    <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;testing_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="p">[:</span><span class="mi">2000</span><span class="p">]</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[:</span><span class="mi">2000</span><span class="p">]</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="p">[:</span><span class="mi">500</span><span class="p">]</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="p">[:</span><span class="mi">500</span><span class="p">]</span>

    <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span> <span class="o">/</span> <span class="mi">255</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">10</span><span class="p">)[</span><span class="n">y_train</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">y_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">10</span><span class="p">)[</span><span class="n">y_test</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="c1"># The second method: unified storage and unified reading</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">CNN</span><span class="p">()</span>
    <span class="n">model_hybrid</span> <span class="o">=</span> <span class="n">model</span>
    <span class="n">model_hybrid</span><span class="o">.</span><span class="n">fc3</span> <span class="o">=</span> <span class="n">Q_DressedQuantumNet</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model_hybrid</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
        <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">model_param_quantum</span> <span class="o">=</span> <span class="n">load_parameters</span><span class="p">(</span><span class="s2">&quot;QCNN_TL_ALL.model&quot;</span><span class="p">)</span>

    <span class="n">model_hybrid</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">model_param_quantum</span><span class="p">)</span>
    <span class="n">model_hybrid</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

    <span class="n">loss_func</span> <span class="o">=</span> <span class="n">SoftmaxCrossEntropy</span><span class="p">()</span>
    <span class="n">eval_losses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">loss_temp</span> <span class="o">=</span><span class="p">[]</span>
    <span class="n">eval_batch_size</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">eval_batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model_hybrid</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="n">np_loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y1</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">correct</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>

        <span class="n">n_eval</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">loss_temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np_loss</span><span class="p">)</span>

    <span class="n">eval_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">loss_temp</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_eval</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Eval Accuracy: </span><span class="si">{</span><span class="n">correct</span> <span class="o">/</span> <span class="p">(</span><span class="n">eval_batch_size</span><span class="o">*</span><span class="n">n_eval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">n_samples_show</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="n">n_samples_show</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">model_hybrid</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">n_samples_show</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model_hybrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">QTensor</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Predicted </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># save classic model parameters</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;./result/QCNN_TL_1.model&#39;</span><span class="p">):</span>
        <span class="n">classcal_cnn_model_making</span><span class="p">()</span>
        <span class="n">classical_cnn_TransferLearning_predict</span><span class="p">()</span>
    <span class="c1">#train quantum circuits.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;use exist cnn model param to train quantum parameters.&quot;</span><span class="p">)</span>
    <span class="n">quantum_cnn_TransferLearning</span><span class="p">()</span>
    <span class="c1">#eval quantum circuits.</span>
    <span class="n">quantum_cnn_TransferLearning_predict</span><span class="p">()</span>
</pre></div>
</div>
<p>Loss on training set</p>
<figure class="align-default">
<img alt="../_images/qcnn_transfer_learning_classical.png" src="../_images/qcnn_transfer_learning_classical.png" />
</figure>
<p>Run classification on test set</p>
<figure class="align-default">
<img alt="../_images/qcnn_transfer_learning_predict.png" src="../_images/qcnn_transfer_learning_predict.png" />
</figure>
</section>
<section id="hybrid-quantum-classical-unet-network-model">
<h3>3.Hybrid quantum classical Unet network model<a class="headerlink" href="#hybrid-quantum-classical-unet-network-model" title="Permalink to this headline">¶</a></h3>
<p>Image segmentation Image segmentation is a classical problem in the research of computer vision and has become a hot
spot in the field of image understanding. Image segmentation is the first step of image analysis, the basis of computer
vision, an important part of image understanding, and one of the most difficult problems in image processing.
The so-called image segmentation refers to the segmentation based on gray, color and spatial texture The image
is divided into several disjoint regions by features such as theory and geometry, so that these features show
consistency or similarity in the same region and obvious differences between different regions. In short,
it is to give a picture and classify each pixel on the picture. Separate the pixel regions belonging
to different objects.</p>
<p>Here, we explore how to partially quantify the classical neural network to create a hybrid quantum classical
<cite>QUnet</cite>  neural network. We will write a simple example of integrating <a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/">pyQPanda</a> with <cite>VQNet</cite> .</p>
<p>Qunet is mainly used to solve the technology of image segmentation.</p>
<p><a class="reference external" href="../../../../../tutorials/QUnet/QUnet_demo.md">QUnet Introduction to algorithm documents</a>    VQNet Sample code：<a class="reference external" href="../../../../examples/qunet_test.py">QUnet</a> 。</p>
<section id="id3">
<h4>Data preparation<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>We will use the data of VOCdevkit/VOC2012 official library as image segmentation data. These samples are divided
into training data training_data and test data testing_data。</p>
<figure class="align-default">
<img alt="../_images/Unet_data_imshow.png" src="../_images/Unet_data_imshow.png" />
</figure>
</section>
<section id="constructing-quantum-circuits">
<h4>Constructing quantum circuits<a class="headerlink" href="#constructing-quantum-circuits" title="Permalink to this headline">¶</a></h4>
<p>In this example, we define a quantum circuit using pyqpanda of the source quantum. The input 3-channel color
image data is compressed into a single channel gray image and stored, and then the feature of the data is
extracted and dimensionality reduced by quantum convolution operation.</p>
<figure class="align-default">
<img alt="../_images/qunet_cir.png" src="../_images/qunet_cir.png" />
</figure>
<p>Import necessary libraries and functions</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.conv</span> <span class="kn">import</span> <span class="n">Conv2D</span><span class="p">,</span> <span class="n">ConvT2D</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn</span> <span class="kn">import</span> <span class="n">activation</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.batch_norm</span> <span class="kn">import</span> <span class="n">BatchNorm2d</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">BinaryCrossEntropy</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim.adam</span> <span class="kn">import</span> <span class="n">Adam</span>

<span class="kn">from</span> <span class="nn">pyvqnet.tensor</span> <span class="kn">import</span> <span class="n">tensor</span>
<span class="kn">from</span> <span class="nn">pyvqnet.tensor.tensor</span> <span class="kn">import</span> <span class="n">QTensor</span>
<span class="kn">import</span> <span class="nn">pyqpanda</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyvqnet.utils.storage</span> <span class="kn">import</span> <span class="n">load_parameters</span><span class="p">,</span> <span class="n">save_parameters</span>

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;TkAgg&#39;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">cv2</span>
</pre></div>
</div>
<p>Preprocessing data</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Preprocessing data</span>
<span class="k">class</span> <span class="nc">PreprocessingData</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">def</span> <span class="nf">processing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">list_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">+</span><span class="s2">&quot;/train&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_path</span><span class="p">)):</span>

            <span class="n">temp_data</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">+</span><span class="s2">&quot;/train&quot;</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">list_path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cv2</span><span class="o">.</span><span class="n">IMREAD_COLOR</span><span class="p">)</span>
            <span class="n">temp_data</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">temp_data</span><span class="p">,</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
            <span class="n">grayimg</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">temp_data</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
            <span class="n">temp_data</span> <span class="o">=</span> <span class="n">grayimg</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">temp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">temp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_data</span><span class="p">)</span>

            <span class="n">label_data</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">+</span><span class="s2">&quot;/label&quot;</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span><span class="n">list_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">IMREAD_COLOR</span><span class="p">)</span>
            <span class="n">label_data</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">label_data</span><span class="p">,</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>

            <span class="n">label_data</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">label_data</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
            <span class="n">label_data</span> <span class="o">=</span> <span class="n">label_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">label_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label_data</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processing</span><span class="p">()</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_data</span><span class="p">)</span>
        <span class="n">y_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x_data</span><span class="p">,</span> <span class="n">y_label</span>

<span class="c1"># Quantum coding circuit</span>
<span class="k">class</span> <span class="nc">QCNN_</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>

    <span class="k">def</span> <span class="nf">encode_cir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">,</span> <span class="n">pixels</span><span class="p">):</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pix</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pixels</span><span class="p">):</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">pix</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">theta</span><span class="p">))</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RZ</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">phi</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cir</span>

    <span class="k">def</span> <span class="nf">entangle_cir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlist</span><span class="p">):</span>
        <span class="n">k_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qlist</span><span class="p">)</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_size</span><span class="p">):</span>
            <span class="n">ctr</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">ctred</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">ctred</span> <span class="o">==</span> <span class="n">k_size</span><span class="p">:</span>
                <span class="n">ctred</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="n">ctr</span><span class="p">],</span> <span class="n">qlist</span><span class="p">[</span><span class="n">ctred</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">cir</span>

    <span class="k">def</span> <span class="nf">qcnn_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">):</span>
        <span class="n">k_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>
        <span class="n">machine</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">MPSQVM</span><span class="p">()</span>
        <span class="n">machine</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>
        <span class="n">qlist</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="n">k_size</span><span class="p">)</span>
        <span class="n">cir</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>

        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encode_cir</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">cir</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entangle_cir</span><span class="p">(</span><span class="n">qlist</span><span class="p">))</span>

        <span class="n">result0</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">prob_run_list</span><span class="p">(</span><span class="n">cir</span><span class="p">,</span> <span class="p">[</span><span class="n">qlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result1</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">prob_run_list</span><span class="p">(</span><span class="n">cir</span><span class="p">,</span> <span class="p">[</span><span class="n">qlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result2</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">prob_run_list</span><span class="p">(</span><span class="n">cir</span><span class="p">,</span> <span class="p">[</span><span class="n">qlist</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result3</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">prob_run_list</span><span class="p">(</span><span class="n">cir</span><span class="p">,</span> <span class="p">[</span><span class="n">qlist</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">result0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">result1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">result2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">result3</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">machine</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">quanconv_</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convolves the input image with many applications of the same quantum circuit.&quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="c1"># Process a squared 2x2 region of the image with a quantum circuit</span>
            <span class="n">q_results</span> <span class="o">=</span> <span class="n">QCNN_</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">qcnn_circuit</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">image</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">image</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">image</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">image</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">j</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</section>
<section id="constructing-hybrid-classical-quantum-neural-network">
<h4>Constructing hybrid classical quantum neural network<a class="headerlink" href="#constructing-hybrid-classical-quantum-neural-network" title="Permalink to this headline">¶</a></h4>
<p>According to the UNET network framework, we use the <cite>VQNet</cite> framework to build the classic network part.
The down sampling neural network layer is used to reduce the dimension and extract features;
The upper sampling neural network layer is used to restore the dimension; The upper and lower sampling layers
are connected through concatenate for feature fusion.</p>
<figure class="align-default">
<img alt="../_images/Unet.png" src="../_images/Unet.png" />
</figure>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition of down sampling neural network layer</span>
<span class="k">class</span> <span class="nc">DownsampleLayer</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ch</span><span class="p">,</span> <span class="n">out_ch</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DownsampleLayer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="n">in_ch</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="n">out_ch</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                            <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d1</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_ch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="n">out_ch</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="n">out_ch</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                            <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d2</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_ch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu2</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv3</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="n">out_ch</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="n">out_ch</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                            <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d3</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_ch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu3</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param x:</span>
<span class="sd">        :return: out(Output to deep)，out_2(enter to next level)，</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d1</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="n">x3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Relu1</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
        <span class="n">x4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">x3</span><span class="p">)</span>
        <span class="n">x5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d2</span><span class="p">(</span><span class="n">x4</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Relu2</span><span class="p">(</span><span class="n">x5</span><span class="p">)</span>
        <span class="n">x6</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv3</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">x7</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d3</span><span class="p">(</span><span class="n">x6</span><span class="p">)</span>
        <span class="n">out_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Relu3</span><span class="p">(</span><span class="n">x7</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">out_2</span>

<span class="c1"># Definition of up sampling neural network layer</span>
<span class="k">class</span> <span class="nc">UpSampleLayer</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ch</span><span class="p">,</span> <span class="n">out_ch</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UpSampleLayer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="n">in_ch</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="n">out_ch</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                            <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d1</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_ch</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="n">out_ch</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="n">out_ch</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                            <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d2</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_ch</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu2</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conv3</span> <span class="o">=</span> <span class="n">ConvT2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="n">out_ch</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="n">out_ch</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                             <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d3</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_ch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu3</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param x: input conv layer</span>
<span class="sd">        :param out: connect with UpsampleLayer</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Relu1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Relu2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Relu3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x_out</span>

<span class="c1"># Unet overall network architecture</span>
<span class="k">class</span> <span class="nc">UNet</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UNet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">out_channels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>

        <span class="c1"># DownSampleLayer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">DownsampleLayer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 3-64</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">DownsampleLayer</span><span class="p">(</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># 64-128</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d3</span> <span class="o">=</span> <span class="n">DownsampleLayer</span><span class="p">(</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out_channels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># 128-256</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d4</span> <span class="o">=</span> <span class="n">DownsampleLayer</span><span class="p">(</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">out_channels</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># 256-512</span>
        <span class="c1"># UpSampleLayer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u1</span> <span class="o">=</span> <span class="n">UpSampleLayer</span><span class="p">(</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">out_channels</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># 512-1024-512</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u2</span> <span class="o">=</span> <span class="n">UpSampleLayer</span><span class="p">(</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">out_channels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># 1024-512-256</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u3</span> <span class="o">=</span> <span class="n">UpSampleLayer</span><span class="p">(</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">out_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># 512-256-128</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u4</span> <span class="o">=</span> <span class="n">UpSampleLayer</span><span class="p">(</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">out_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 256-128-64</span>
        <span class="c1"># output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output_channels</span><span class="o">=</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                            <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d1</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output_channels</span><span class="o">=</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                            <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d2</span> <span class="o">=</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Relu2</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv3</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="n">out_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                            <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigmoid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">out_1</span><span class="p">,</span> <span class="n">out1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">out_2</span><span class="p">,</span> <span class="n">out2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d2</span><span class="p">(</span><span class="n">out1</span><span class="p">)</span>
        <span class="n">out_3</span><span class="p">,</span> <span class="n">out3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d3</span><span class="p">(</span><span class="n">out2</span><span class="p">)</span>
        <span class="n">out_4</span><span class="p">,</span> <span class="n">out4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d4</span><span class="p">(</span><span class="n">out3</span><span class="p">)</span>

        <span class="n">out5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u1</span><span class="p">(</span><span class="n">out4</span><span class="p">)</span>
        <span class="n">cat_out5</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">out5</span><span class="p">,</span> <span class="n">out_4</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">out6</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u2</span><span class="p">(</span><span class="n">cat_out5</span><span class="p">)</span>
        <span class="n">cat_out6</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">out6</span><span class="p">,</span> <span class="n">out_3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">out7</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u3</span><span class="p">(</span><span class="n">cat_out6</span><span class="p">)</span>
        <span class="n">cat_out7</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">out7</span><span class="p">,</span> <span class="n">out_2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">out8</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u4</span><span class="p">(</span><span class="n">cat_out7</span><span class="p">)</span>
        <span class="n">cat_out8</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">out8</span><span class="p">,</span> <span class="n">out_1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">cat_out8</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d1</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Relu1</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BatchNorm2d2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Relu2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv3</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</section>
<section id="training-and-model-saving">
<h4>Training and model saving<a class="headerlink" href="#training-and-model-saving" title="Permalink to this headline">¶</a></h4>
<p>Through the above code example, we have defined the model. Similar to the training of classical neural network model,
we also need to instantiate the model, define the loss function and optimizer, and define the whole training and
testing process. For the hybrid neural network model as shown in the figure below, we calculate the loss value
forward through cyclic input data, automatically calculate the gradient of each parameter to be trained in
reverse calculation, and use the optimizer to optimize the parameters until the number of
iterations meets the preset value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyDataset</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_data</span><span class="p">,</span> <span class="n">x_label</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_set</span> <span class="o">=</span> <span class="n">x_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">x_label</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">img</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_set</span><span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="n">img_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">target_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">img</span> <span class="o">=</span> <span class="n">img_np</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">target_np</span>
        <span class="k">return</span> <span class="n">img</span><span class="p">,</span> <span class="n">target</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_set</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;./result&quot;</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="s2">&quot;./result&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;./Intermediate_results&quot;</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="s2">&quot;./Intermediate_results&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1"># prepare train/test data and label</span>
<span class="n">path0</span> <span class="o">=</span> <span class="s1">&#39;../../data/dataset/Unet_data_src&#39;</span>
<span class="n">path1</span> <span class="o">=</span> <span class="s1">&#39;../../data/dataset/Unet_data_src&#39;</span>
<span class="n">train_images</span><span class="p">,</span> <span class="n">train_labels</span> <span class="o">=</span> <span class="n">PreprocessingData</span><span class="p">(</span><span class="n">path0</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">test_images</span><span class="p">,</span> <span class="n">test_labels</span> <span class="o">=</span> <span class="n">PreprocessingData</span><span class="p">(</span><span class="n">path1</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;train: &#39;</span><span class="p">,</span> <span class="n">train_images</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">test: &#39;</span><span class="p">,</span> <span class="n">test_images</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;train: &#39;</span><span class="p">,</span> <span class="n">train_labels</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">test: &#39;</span><span class="p">,</span> <span class="n">test_labels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">train_images</span> <span class="o">=</span> <span class="n">train_images</span> <span class="o">/</span> <span class="mi">255</span>
<span class="n">test_images</span> <span class="o">=</span> <span class="n">test_images</span> <span class="o">/</span> <span class="mi">255</span>

<span class="c1"># use quantum encoder to preprocess data</span>
<span class="c1"># PREPROCESS = True</span>
<span class="n">PREPROCESS</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">if</span> <span class="n">PREPROCESS</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Quantum pre-processing of train images:&quot;</span><span class="p">)</span>
    <span class="n">q_train_images</span> <span class="o">=</span> <span class="n">QuantumDataPreprocessing</span><span class="p">(</span><span class="n">train_images</span><span class="p">)</span>
    <span class="n">q_test_images</span> <span class="o">=</span> <span class="n">QuantumDataPreprocessing</span><span class="p">(</span><span class="n">test_images</span><span class="p">)</span>
    <span class="n">q_train_label</span> <span class="o">=</span> <span class="n">QuantumDataPreprocessing</span><span class="p">(</span><span class="n">train_labels</span><span class="p">)</span>
    <span class="n">q_test_label</span> <span class="o">=</span> <span class="n">QuantumDataPreprocessing</span><span class="p">(</span><span class="n">test_labels</span><span class="p">)</span>

    <span class="c1"># Save pre-processed images</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Quantum Data Saving...&#39;</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;../../data/dataset/q_train.npy&quot;</span><span class="p">,</span> <span class="n">q_train_images</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;./data/dataset/q_test.npy&quot;</span><span class="p">,</span> <span class="n">q_test_images</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;../../data/dataset/q_train_label.npy&quot;</span><span class="p">,</span> <span class="n">q_train_label</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;./data/dataset/q_test_label.npy&quot;</span><span class="p">,</span> <span class="n">q_test_label</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Quantum Data Saving Over!&#39;</span><span class="p">)</span>

<span class="c1"># loading quantum data</span>
<span class="n">SAVE_PATH</span> <span class="o">=</span> <span class="s2">&quot;../../data/dataset/&quot;</span>
<span class="n">train_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">SAVE_PATH</span> <span class="o">+</span> <span class="s2">&quot;q_train.npy&quot;</span><span class="p">)</span>
<span class="n">train_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">SAVE_PATH</span> <span class="o">+</span> <span class="s2">&quot;q_train_label.npy&quot;</span><span class="p">)</span>
<span class="n">test_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">SAVE_PATH</span> <span class="o">+</span> <span class="s2">&quot;q_test.npy&quot;</span><span class="p">)</span>
<span class="n">test_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">SAVE_PATH</span> <span class="o">+</span> <span class="s2">&quot;q_test_label.npy&quot;</span><span class="p">)</span>

<span class="n">train_x</span> <span class="o">=</span> <span class="n">train_x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">test_x</span> <span class="o">=</span> <span class="n">test_x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">train_labels</span> <span class="o">=</span> <span class="n">train_labels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">test_labels</span> <span class="o">=</span> <span class="n">test_labels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">train_y</span> <span class="o">=</span> <span class="n">train_labels</span>
<span class="n">test_y</span> <span class="o">=</span> <span class="n">test_labels</span>

<span class="n">trainset</span> <span class="o">=</span> <span class="n">MyDataset</span><span class="p">(</span><span class="n">train_x</span><span class="p">,</span> <span class="n">train_y</span><span class="p">)</span>

<span class="n">x_train</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">y_label</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">UNet</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">loss_func</span> <span class="o">=</span> <span class="n">BinaryCrossEntropy</span><span class="p">()</span>
<span class="n">epochs</span> <span class="o">=</span> <span class="mi">200</span>

<span class="n">loss_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">SAVE_FLAG</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">temp_loss</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./result/result.txt&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
    <span class="n">total_loss</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trainset</span><span class="p">):</span>
        <span class="n">x_img</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x_img_Qtensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">x_img</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">y_img</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">y_img_Qtensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">y_img</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">img_out</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x_img_Qtensor</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;==========</span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">==================&quot;</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y_img_Qtensor</span><span class="p">,</span> <span class="n">img_out</span><span class="p">)</span>  <span class="c1"># target output</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;predict&quot;</span><span class="p">)</span>
            <span class="n">img_out_tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">img_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&gt;=</span> <span class="s1">&#39;3.4.2&#39;</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_out_tensor</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_out_tensor</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">)</span>
            <span class="n">y_img_tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_img_Qtensor</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&gt;=</span> <span class="s1">&#39;3.4.2&#39;</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_img_tensor</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_img_tensor</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;./Intermediate_results/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.jpg&quot;</span><span class="p">)</span>

        <span class="n">loss_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> - </span><span class="si">{}</span><span class="s2"> loss_data: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">loss_data</span><span class="p">))</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>
        <span class="n">total_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_data</span><span class="p">)</span>

    <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">total_loss</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_loss</span><span class="p">))</span>
    <span class="n">out_read</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./result/result.txt&quot;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
    <span class="n">out_read</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">out_read</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>
    <span class="n">out_read</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.0f}</span><span class="s2"> loss is : </span><span class="si">{:.10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">SAVE_FLAG</span><span class="p">:</span>
        <span class="n">temp_loss</span> <span class="o">=</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">save_parameters</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s2">&quot;./result/Q-Unet_End.model&quot;</span><span class="p">)</span>
        <span class="n">SAVE_FLAG</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">temp_loss</span> <span class="o">&gt;</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">temp_loss</span> <span class="o">=</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">save_parameters</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s2">&quot;./result/Q-Unet_End.model&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="data-visualization">
<h4>Data visualization<a class="headerlink" href="#data-visualization" title="Permalink to this headline">¶</a></h4>
<p>The loss function curve of training data is displayed and saved, and the test data results are saved.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out_read</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./result/result.txt&quot;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">lines_read</span> <span class="o">=</span> <span class="n">out_read</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
<span class="n">data_read</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines_read</span><span class="p">:</span>
    <span class="n">float_line</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">data_read</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">float_line</span><span class="p">)</span>
<span class="n">out_read</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data_read</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Unet Training&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Training Iterations&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Loss&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;./result/traing_loss.jpg&quot;</span><span class="p">)</span>

<span class="n">modela</span> <span class="o">=</span> <span class="n">load_parameters</span><span class="p">(</span><span class="s2">&quot;./result/Q-Unet_End.model&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----------------PREDICT-------------&quot;</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trainset</span><span class="p">):</span>
    <span class="n">x_img</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">x_img_Qtensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">x_img</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">y_img</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>
    <span class="n">y_img_Qtensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">y_img</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">img_out</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x_img_Qtensor</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y_img_Qtensor</span><span class="p">,</span> <span class="n">img_out</span><span class="p">)</span>
    <span class="n">loss_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> loss_eval: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">loss_data</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;predict&quot;</span><span class="p">)</span>
    <span class="n">img_out_tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">img_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&gt;=</span> <span class="s1">&#39;3.4.2&#39;</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_out_tensor</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_out_tensor</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">)</span>
    <span class="n">y_img_tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">y_img_Qtensor</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&gt;=</span> <span class="s1">&#39;3.4.2&#39;</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_img_tensor</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_img_tensor</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;./result/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_1&quot;</span> <span class="o">+</span> <span class="s2">&quot;.jpg&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;end!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Loss on training set</p>
<figure class="align-default">
<img alt="../_images/qunet_train_loss.png" src="../_images/qunet_train_loss.png" />
</figure>
<p>Run classification on test set</p>
<figure class="align-default">
<img alt="../_images/qunet_eval_1.jpg" src="../_images/qunet_eval_1.jpg" />
</figure>
<figure class="align-default">
<img alt="../_images/qunet_eval_2.jpg" src="../_images/qunet_eval_2.jpg" />
</figure>
<figure class="align-default">
<img alt="../_images/qunet_eval_3.jpg" src="../_images/qunet_eval_3.jpg" />
</figure>
</section>
</section>
</section>
<section id="unsupervised-learning">
<h2>Unsupervised learning<a class="headerlink" href="#unsupervised-learning" title="Permalink to this headline">¶</a></h2>
<section id="quantum-kmeans">
<h3>1 Quantum Kmeans<a class="headerlink" href="#quantum-kmeans" title="Permalink to this headline">¶</a></h3>
<section id="introduce">
<h4>1.1 Introduce<a class="headerlink" href="#introduce" title="Permalink to this headline">¶</a></h4>
<p>Clustering algorithm is a typical unsupervised learning algorithm, which is mainly used to automatically classify similar samples into one class. In the clustering algorithm, samples are divided into different categories according to the similarity between samples. For different similarity calculation methods, different clustering results will be obtained. The common similarity calculation method is Euclidean distance method. What we want to show is the quantum k-means algorithm. K-means algorithm is a distance based clustering algorithm. It takes distance as the evaluation index of similarity, that is, the closer the distance between two objects, the greater the similarity. The algorithm considers that clusters are composed of objects close to each other, so compact and independent clusters are the ultimate goal.</p>
<p>Quantum kmeans quantum machine learning model can also be developed in VQNet. An example of the quantum kmeans clustering task is given below. Through the quantum circuit, we can construct a measurement that is positively correlated with the Euclidean distance of the variables of classical machine learning, so as to achieve the goal of finding the nearest neighbor.</p>
</section>
<section id="introduction-to-algorithm-principle">
<h4>1.2 Introduction to algorithm principle<a class="headerlink" href="#introduction-to-algorithm-principle" title="Permalink to this headline">¶</a></h4>
<p>The implementation of quantum k-means algorithm mainly uses swap test to compare the distance between input data points. Randomly select k points from N data points as centroids, measure the distance from each point to each centroid, assign it to the nearest centroid class, recalculate the centroid of each class, and iterate 2 to 3 steps until the new centroid is equal to or less than the specified threshold. In our example, we select 100 data points and 2 centroids, and use cswap circuit to calculate the distance.
Finally, we obtained two data point clusters. <span class="math notranslate nohighlight">\(|0\rangle\)</span> is an auxiliary bit, through the H logic gate, the qubit will become <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)\)</span>. Under the control of  <span class="math notranslate nohighlight">\(|1\rangle\)</span> qubit,
The quantum circuit will flip <span class="math notranslate nohighlight">\(|x\rangle\)</span> and <span class="math notranslate nohighlight">\(|y\rangle​\)</span> . Finally get the result:</p>
<div class="math notranslate nohighlight">
\[|0_{anc}\rangle |x\rangle |y\rangle \rightarrow \frac{1}{2}|0_{anc}\rangle(|xy\rangle + |yx\rangle) + \frac{1}{2}|1_{anc}\rangle(|xy\rangle - |yx\rangle)\]</div>
<p>If we measure the auxiliary qubit separately, the probability of the final state of the ground state <span class="math notranslate nohighlight">\(|1\rangle\)</span> is:</p>
<div class="math notranslate nohighlight">
\[P(|1_{anc}\rangle) = \frac{1}{2} - \frac{1}{2}|\langle x | y \rangle|^2\]</div>
<p>The Euclidean distance between two quantum states is as follows:</p>
<div class="math notranslate nohighlight">
\[Euclidean \ distance = \sqrt{(2 - 2|\langle x | y \rangle|)}\]</div>
<p>Visible measurement qubit <span class="math notranslate nohighlight">\(|1\rangle\)</span> ​ is positively correlated with Euclidean distance. The quantum circuit of this algorithm is as follows：</p>
<figure class="align-default">
<img alt="../_images/Kmeans.jpg" src="../_images/Kmeans.jpg" />
</figure>
</section>
<section id="vqnet-implementation">
<h4>1.3 VQNet  implementation<a class="headerlink" href="#vqnet-implementation" title="Permalink to this headline">¶</a></h4>
<section id="environmental-preparation">
<h5>1.3.1 Environmental preparation<a class="headerlink" href="#environmental-preparation" title="Permalink to this headline">¶</a></h5>
<p>The environment adopts Python 3 8. It is recommended to use CONDA for environment configuration. It comes with numpy, SciPy, Matplotlib, sklearn and other toolkits for easy use. If the python environment is adopted, relevant packages need to be installed, and the following environment pyvqnet needs to be prepared</p>
</section>
<section id="id4">
<h5>1.3.2 Data preparation<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>The data is randomly generated by make_blobs under SciPy, and the function is defined to generate Gaussian distribution data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="c1"># According to the data amount n of the data, the cluster center K and the data standard deviation std return the corresponding data point and the cluster center point</span>
<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">std</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">cluster_std</span><span class="o">=</span><span class="n">std</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">points</span><span class="p">,</span> <span class="n">centers</span>
</pre></div>
</div>
</section>
<section id="id5">
<h5>1.3.3 Quantum circuit<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>Constructing quantum circuits using VQNet</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># The input quantum gate rotation angle is calculated according to the input coordinate point d (x, y)</span>
<span class="k">def</span> <span class="nf">get_theta</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">theta</span>

<span class="c1"># The quantum circuit is constructed according to the input quantum data points</span>
<span class="k">def</span> <span class="nf">qkmeans_circuits</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>

    <span class="n">theta_1</span> <span class="o">=</span> <span class="n">get_theta</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">theta_2</span> <span class="o">=</span> <span class="n">get_theta</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">machine</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">CPUQVM</span><span class="p">()</span>
    <span class="n">machine</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>

    <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

    <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">U3</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">theta_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">U3</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">theta_2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

    <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">SWAP</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">control</span><span class="p">([</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

    <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
    <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">pq</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">cbits</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">result</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;001&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1024.0</span>
</pre></div>
</div>
</section>
<section id="id6">
<h5>1.3.4 Data visualization<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>Visual calculation of relevant clustering data</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Visualization of scatter points and cluster centers</span>
<span class="k">def</span> <span class="nf">draw_plot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">label</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">centers</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="cluster-calculation">
<h5>1.3.5 Cluster calculation<a class="headerlink" href="#cluster-calculation" title="Permalink to this headline">¶</a></h5>
<p>Calculate the cluster center of relevant cluster data</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Randomly generate cluster center points</span>
<span class="k">def</span> <span class="nf">initialize_centers</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">size</span><span class="o">=</span><span class="n">k</span><span class="p">),:]</span>


<span class="k">def</span> <span class="nf">find_nearest_neighbour</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">centroids</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">centroids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">centers</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">min_dis</span> <span class="o">=</span> <span class="mi">10000</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>

            <span class="n">temp_dis</span> <span class="o">=</span> <span class="n">qkmeans_circuits</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>

            <span class="k">if</span> <span class="n">temp_dis</span> <span class="o">&lt;</span> <span class="n">min_dis</span><span class="p">:</span>
                <span class="n">min_dis</span> <span class="o">=</span> <span class="n">temp_dis</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">j</span>
        <span class="n">centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>

    <span class="k">return</span> <span class="n">centers</span>

<span class="k">def</span> <span class="nf">find_centroids</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">centers</span><span class="p">):</span>

    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">centroids</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>

        <span class="n">cur_i</span> <span class="o">=</span> <span class="n">centers</span> <span class="o">==</span> <span class="n">i</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">cur_i</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">cur_i</span><span class="p">]</span>
        <span class="n">centroids</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">centroids</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">centroids</span>

<span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mf">30.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="mi">15</span>
        <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">x</span>

    <span class="k">return</span> <span class="n">points</span>


<span class="k">def</span> <span class="nf">qkmean_run</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># number of data points</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Number of centers</span>
    <span class="n">std</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># std of datapoints</span>

    <span class="n">points</span><span class="p">,</span> <span class="n">o_centers</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span>  <span class="c1"># dataset</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>  <span class="c1"># Normalize dataset</span>

    <span class="n">centroids</span> <span class="o">=</span> <span class="n">initialize_centers</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>  <span class="c1"># Intialize centroids</span>

    <span class="n">epoch</span> <span class="o">=</span> <span class="mi">9</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">centroids</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">draw_plot</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">o_centers</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># 运行算法</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epoch</span><span class="p">):</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">find_nearest_neighbour</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">centroids</span><span class="p">)</span>  <span class="c1"># find nearest centers</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="n">find_centroids</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">centers</span><span class="p">)</span>  <span class="c1"># find centroids</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">draw_plot</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">centers</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># Run program entry</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">qkmean_run</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="data-distribution-before-clustering">
<h5>1.3.6 Data distribution before clustering<a class="headerlink" href="#data-distribution-before-clustering" title="Permalink to this headline">¶</a></h5>
<figure class="align-default">
<img alt="../_images/ep_1.png" src="../_images/ep_1.png" />
</figure>
</section>
<section id="data-distribution-after-clustering">
<h5>1.3.7 Data distribution after clustering<a class="headerlink" href="#data-distribution-after-clustering" title="Permalink to this headline">¶</a></h5>
<figure class="align-default">
<img alt="../_images/ep_9.png" src="../_images/ep_9.png" />
</figure>
</section>
</section>
</section>
</section>
<section id="model-training-using-quantum-computing-layer-in-vqnet">
<h2>Model training using quantum computing layer in VQNet<a class="headerlink" href="#model-training-using-quantum-computing-layer-in-vqnet" title="Permalink to this headline">¶</a></h2>
<p>The following are examples of using QuantumLayer，NoiseQuantumLayer，VQCLayer and Compatiblelayer.</p>
<section id="model-training-using-quantumlayer-in-vqnet">
<h3>Model training using quantumlayer in VQNet<a class="headerlink" href="#model-training-using-quantumlayer-in-vqnet" title="Permalink to this headline">¶</a></h3>
<p>In examples, a complete example of variable sub circuit using QuantumLayer is implemented qvc_quantumlayer_test.py</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span><span class="nn">os</span>


<span class="nb">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim</span> <span class="kn">import</span> <span class="n">sgd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.linear</span> <span class="kn">import</span> <span class="n">Linear</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">CategoricalCrossEntropy</span>

<span class="kn">from</span> <span class="nn">pyvqnet.tensor.tensor</span> <span class="kn">import</span> <span class="n">QTensor</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">pyvqnet.qnn.qvc.qvc_model</span> <span class="kn">import</span> <span class="n">qvc_circuits</span>
<span class="kn">from</span> <span class="nn">pyvqnet.qnn.quantumlayer</span> <span class="kn">import</span> <span class="n">QuantumLayer</span>
<span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>


<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">shape</span><span class="p">):</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
                <span class="c1">#self.qvc = Qvc(shape)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qvc</span> <span class="o">=</span> <span class="n">QuantumLayer</span><span class="p">(</span><span class="n">qvc_circuits</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qvc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">PATH</span><span class="p">):</span>
        <span class="n">datasets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">PATH</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">label</span>

<span class="k">def</span> <span class="nf">dataloader</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="n">batch_size</span><span class="p">):</span>
                        <span class="n">random_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">random_index</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">label</span><span class="p">[</span><span class="n">random_index</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="n">batch_size</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">batch_size</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">batch_size</span><span class="p">],</span> <span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">batch_size</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">get_accuary</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">label</span><span class="p">):</span>
        <span class="n">result</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">score</span>

<span class="k">def</span> <span class="nf">Run</span><span class="p">():</span>
        <span class="n">nqubits</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">num_layer</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">([</span><span class="n">num_layer</span><span class="p">,</span><span class="n">nqubits</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">sgd</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span><span class="n">lr</span> <span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">epoch</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start training..............&quot;</span><span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
        <span class="n">PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;..//..//data//qvc_data.txt&#39;</span><span class="p">)</span>
        <span class="n">datas</span><span class="p">,</span><span class="n">labels</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">PATH</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epoch</span><span class="p">):</span>
                <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
                <span class="n">sum_loss</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">accuary</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">data</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">(</span><span class="n">datas</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="n">batch_size</span><span class="p">):</span>
                        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
                        <span class="n">data</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

                        <span class="n">loss_b</span> <span class="o">=</span> <span class="n">loss</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">result</span><span class="p">)</span>
                        <span class="n">loss_b</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
                        <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>
                        <span class="n">sum_loss</span> <span class="o">+=</span> <span class="n">loss_b</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                        <span class="n">count</span><span class="o">+=</span><span class="n">batch_size</span>
                        <span class="n">accuary</span> <span class="o">+=</span> <span class="n">get_accuary</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;epoch:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, #### loss:</span><span class="si">{</span><span class="n">sum_loss</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2"> #####accuray:</span><span class="si">{</span><span class="n">accuary</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start testing..............&quot;</span><span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">test_PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;../../data/qvc_data_test.txt&#39;</span><span class="p">)</span>
        <span class="n">test_data</span><span class="p">,</span> <span class="n">test_label</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">test_PATH</span><span class="p">)</span>
        <span class="n">test_batch_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">accuary</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sum_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">testd</span><span class="p">,</span><span class="n">testl</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">(</span><span class="n">test_data</span><span class="p">,</span><span class="n">test_label</span><span class="p">,</span><span class="n">test_batch_size</span><span class="p">):</span>
                <span class="n">testd</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">testd</span><span class="p">)</span>
                <span class="n">test_result</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">testd</span><span class="p">)</span>
                <span class="n">test_loss</span> <span class="o">=</span> <span class="n">loss</span><span class="p">(</span><span class="n">testl</span><span class="p">,</span><span class="n">test_result</span><span class="p">)</span>
                <span class="n">sum_loss</span> <span class="o">+=</span> <span class="n">test_loss</span>
                <span class="n">count</span><span class="o">+=</span><span class="n">test_batch_size</span>
                <span class="n">accuary</span> <span class="o">+=</span> <span class="n">get_accuary</span><span class="p">(</span><span class="n">test_result</span><span class="p">,</span><span class="n">testl</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;test:---------------&gt;loss:</span><span class="si">{</span><span class="n">sum_loss</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2"> #####accuray:</span><span class="si">{</span><span class="n">accuary</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

        <span class="n">Run</span><span class="p">()</span>
</pre></div>
</div>
<p>Loss and accuracy results of the run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">start</span> <span class="n">training</span><span class="o">..............</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="c1">#### loss:[0.20585182] #####accuray:0.6</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="c1">#### loss:[0.17479989] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="c1">#### loss:[0.12679021] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="c1">#### loss:[0.11088503] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="c1">#### loss:[0.10598478] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="c1">#### loss:[0.10482856] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="c1">#### loss:[0.10453037] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="c1">#### loss:[0.10445572] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="c1">#### loss:[0.10442699] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span> <span class="c1">#### loss:[0.10442187] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="c1">#### loss:[0.10442089] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span> <span class="c1">#### loss:[0.10442062] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="c1">#### loss:[0.10442055] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">13</span><span class="p">,</span> <span class="c1">#### loss:[0.10442055] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">14</span><span class="p">,</span> <span class="c1">#### loss:[0.10442055] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">15</span><span class="p">,</span> <span class="c1">#### loss:[0.10442055] #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span> <span class="c1">#### loss:[0.10442055] #####accuray:1.0</span>

<span class="n">start</span> <span class="n">testing</span><span class="o">..............</span>
<span class="p">[</span><span class="mf">0.3132616580</span><span class="p">]</span>
<span class="n">test</span><span class="p">:</span><span class="o">---------------&gt;</span><span class="n">loss</span><span class="p">:</span><span class="n">QTensor</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#####accuray:1.0</span>
</pre></div>
</div>
</section>
<section id="model-training-using-noisequantumlayer-in-vqnet">
<h3>Model training using NoiseQuantumLayer in VQNet<a class="headerlink" href="#model-training-using-noisequantumlayer-in-vqnet" title="Permalink to this headline">¶</a></h3>
<p>In examples, a complete example of variable sub circuit using NoiseQuantumLayer is implemented hqcnn_noise_test.py</p>
<p>An example of a complete noisy quantum machine learning model is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>



<span class="kn">import</span> <span class="nn">pyvqnet</span>
<span class="kn">from</span> <span class="nn">pyvqnet.data</span> <span class="kn">import</span> <span class="n">mnist</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.linear</span> <span class="kn">import</span> <span class="n">Linear</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.conv</span> <span class="kn">import</span> <span class="n">Conv2D</span>

<span class="kn">from</span> <span class="nn">pyvqnet.nn</span> <span class="kn">import</span> <span class="n">activation</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.pooling</span> <span class="kn">import</span> <span class="n">MaxPool2D</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.dropout</span> <span class="kn">import</span> <span class="n">Dropout</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.batch_norm</span> <span class="kn">import</span> <span class="n">BatchNorm2d</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">CategoricalCrossEntropy</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">BinaryCrossEntropy</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim.sgd</span> <span class="kn">import</span> <span class="n">SGD</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim.adam</span> <span class="kn">import</span> <span class="n">Adam</span>
<span class="kn">from</span> <span class="nn">pyvqnet.data.data</span> <span class="kn">import</span> <span class="n">data_generator</span>
<span class="kn">from</span> <span class="nn">pyvqnet.tensor</span> <span class="kn">import</span> <span class="n">tensor</span>
<span class="kn">from</span> <span class="nn">pyvqnet.tensor.tensor</span> <span class="kn">import</span> <span class="n">QTensor</span>
<span class="kn">import</span> <span class="nn">pyqpanda</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyvqnet.qnn.quantumlayer</span> <span class="kn">import</span> <span class="n">NoiseQuantumLayer</span><span class="p">,</span><span class="n">QuantumLayer</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="k">try</span><span class="p">:</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;TkAgg&#39;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="n">grad_time</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">forward_time</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">forward_time_sum</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span><span class="n">param</span><span class="p">,</span><span class="n">qubits</span><span class="p">,</span><span class="n">cbits</span><span class="p">,</span><span class="n">machine</span><span class="p">):</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>

        <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">RY</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">prog</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QProg</span><span class="p">()</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
        <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">measure_all</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">cbits</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">cbits</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># Compute probabilities for each state</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="mi">100</span>
        <span class="c1"># Get state expectation</span>
        <span class="n">expectation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">states</span> <span class="o">*</span> <span class="n">probabilities</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expectation</span>



<span class="k">class</span> <span class="nc">Net</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">Net</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxpool1</span> <span class="o">=</span> <span class="n">MaxPool2D</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxpool2</span> <span class="o">=</span> <span class="n">MaxPool2D</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hybrid</span> <span class="o">=</span> <span class="n">NoiseQuantumLayer</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s2">&quot;noise&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fc3</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxpool1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxpool2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hybrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>The model is a hybrid quantum circuit and classical network model, in which the quantum circuit part uses <code class="docutils literal notranslate"><span class="pre">NoiseQuantumLayer</span></code> to simulate the quantum circuit plus noise model. This model is used to classify 0 and 1 handwritten digits in MNIST database.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_mnist</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;training_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;..//..//data//MNIST_data&quot;</span><span class="p">):</span>         <span class="c1"># load data</span>
        <span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">struct</span>
        <span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">pyarray</span>
        <span class="k">if</span> <span class="n">dataset</span> <span class="o">==</span> <span class="s2">&quot;training_data&quot;</span><span class="p">:</span>
                <span class="n">fname_image</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;train-images.idx3-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">fname_label</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;train-labels.idx1-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dataset</span> <span class="o">==</span> <span class="s2">&quot;testing_data&quot;</span><span class="p">:</span>
                <span class="n">fname_image</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;t10k-images.idx3-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">fname_label</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;t10k-labels.idx1-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dataset must be &#39;training_data&#39; or &#39;testing_data&#39;&quot;</span><span class="p">)</span>

        <span class="n">flbl</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_label</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">magic_nr</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;II&quot;</span><span class="p">,</span> <span class="n">flbl</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
        <span class="n">lbl</span> <span class="o">=</span> <span class="n">pyarray</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">flbl</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="n">flbl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">fimg</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_image</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">magic_nr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;IIII&quot;</span><span class="p">,</span> <span class="n">fimg</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">pyarray</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">fimg</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="n">fimg</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">lbl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="n">digits</span><span class="p">]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">:</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lbl</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">def</span> <span class="nf">data_select</span><span class="p">(</span><span class="n">train_num</span><span class="p">,</span> <span class="n">test_num</span><span class="p">):</span>
        <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;training_data&quot;</span><span class="p">)</span>  <span class="c1"># load train data</span>
        <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;testing_data&quot;</span><span class="p">)</span>
        <span class="n">idx_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_train</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">train_num</span><span class="p">],</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_train</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">train_num</span><span class="p">])</span>

        <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="p">[</span><span class="n">idx_train</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="n">idx_train</span><span class="p">]</span>

        <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span> <span class="o">/</span> <span class="mi">255</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">y_train</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Test Leaving only labels 0 and 1</span>
        <span class="n">idx_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_test</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">test_num</span><span class="p">],</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_test</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">test_num</span><span class="p">])</span>

        <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="p">[</span><span class="n">idx_test</span><span class="p">]</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="p">[</span><span class="n">idx_test</span><span class="p">]</span>
        <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span> <span class="o">/</span> <span class="mi">255</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">y_test</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
        <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">data_select</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
        <span class="c1"># train sample:200</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Net</span><span class="p">()</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.005</span><span class="p">)</span>
        <span class="n">loss_func</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>

        <span class="n">epochs</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">loss_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eval_loss_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>

        <span class="n">eval_time</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">F1</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;hqcnn_noise_train_rlt.txt&quot;</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">F2</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;hqcnn_noise_eval_rlt.txt&quot;</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
                <span class="n">total_loss</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="nb">iter</span>  <span class="o">=</span> <span class="mi">0</span>
                <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">n_train</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="nb">iter</span> <span class="o">+=</span><span class="mi">1</span>

                        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>

                        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
                        <span class="c1"># Forward pass</span>
                        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                        <span class="c1"># Calculating loss</span>
                        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>  <span class="c1"># target output</span>
                        <span class="n">loss_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                        <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">correct</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
                        <span class="n">n_train</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="c1"># Backward pass</span>
                        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
                        <span class="c1"># Optimize the weights</span>
                        <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>
                        <span class="n">total_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_np</span><span class="p">)</span>

                <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">total_loss</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_loss</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="mf">100.</span> <span class="o">*</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">epochs</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.0f}</span><span class="s2"> loss is : </span><span class="si">{:.10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">F1</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_train</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
                <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">total_loss1</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">eval_time1</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">start_init1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="n">start_time1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
                        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

                        <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">correct</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
                        <span class="n">n_eval</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="n">end_time1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="n">eval_time1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_time1</span> <span class="o">-</span> <span class="n">start_time1</span><span class="p">)</span>
                        <span class="n">loss_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                        <span class="n">total_loss1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_np</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Eval Accuracy: </span><span class="si">{</span><span class="n">correct</span> <span class="o">/</span> <span class="n">n_eval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">end_init1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;predict run all epochs time </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end_init1</span> <span class="o">-</span> <span class="n">start_init1</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;predict mean time:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eval_time1</span><span class="p">)))</span>
                <span class="n">F2</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">total_loss1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_loss1</span><span class="p">)</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">correct</span><span class="o">/</span><span class="n">n_eval</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">F1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">F2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Comparing the classification results of machine learning models of noisy quantum circuits and ideal quantum circuits, the loss change curve and acc change curve are as follows:</p>
<img alt="../_images/noise_1.png" src="../_images/noise_1.png" />
<img alt="../_images/noise_2.png" src="../_images/noise_2.png" />
</section>
<section id="run-model-training-of-qiskit-line-in-vqnet-using-qiskitlayer">
<span id="my-reference-label"></span><h3>Run model training of qiskit line in VQNet using QiskitLayer<a class="headerlink" href="#run-model-training-of-qiskit-line-in-vqnet-using-qiskitlayer" title="Permalink to this headline">¶</a></h3>
<p>In VQNet, we can also use IBM’s qiskit quantum computing library for quantum machine learning tasks.</p>
<p>VQNet implements the qiskit quantum circuit operation class <code class="docutils literal notranslate"><span class="pre">QiskitLayer</span></code>, which inherits from <code class="docutils literal notranslate"><span class="pre">Compatiblelayer</span></code>, <code class="docutils literal notranslate"><span class="pre">Compatiblelayer</span></code> is used to be compatible with other framework circuits to VQNet. A class needs to be passed in the parameters of constructing <code class="docutils literal notranslate"><span class="pre">QiskitLayer</span></code>, which defines the qiksit quantum circuit <code class="docutils literal notranslate"><span class="pre">qiskit.QuantumCircuit</span></code> and its running and measuring function <code class="docutils literal notranslate"><span class="pre">run</span></code>. The <code class="docutils literal notranslate"><span class="pre">run</span></code> function needs to bind the input value to the quantum circuit of qiskit. Using <code class="docutils literal notranslate"><span class="pre">QiskitLayer</span></code>, the input of quantum circuit and the automatic differentiation of parameters can be realized by VQNet.</p>
<p>Referring to the above hybrid quantum classical machine learning example hqcnn for MNIST classification task, we use qiskit to build a class <code class="docutils literal notranslate"><span class="pre">QISKIT_VQC</span></code> 。 Where <code class="docutils literal notranslate"><span class="pre">self._circuit</span></code> variable is a quantum circuit, <code class="docutils literal notranslate"><span class="pre">self.input</span></code> is a variable input parameter. In the <code class="docutils literal notranslate"><span class="pre">run</span></code> function, you need to use the <code class="docutils literal notranslate"><span class="pre">assign_parameters</span></code> bind parameters and use <code class="docutils literal notranslate"><span class="pre">self.backend.run</span></code> run.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are other variable parameters in the circuit, new parameters need to be defined, such as <code class="docutils literal notranslate"><span class="pre">self.theta</span> <span class="pre">=</span> <span class="pre">[qiskit.circuit.Parameter('theta1'),qiskit.circuit.Parameter('theta2')]</span></code> ，and in the <code class="docutils literal notranslate"><span class="pre">run</span></code> function, you need to use the <code class="docutils literal notranslate"><span class="pre">assign_parameters</span></code> binding parameters.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span><span class="nn">os</span>

<span class="kn">import</span> <span class="nn">pyvqnet.tensor.tensor</span> <span class="k">as</span> <span class="nn">tensor</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.linear</span> <span class="kn">import</span> <span class="n">Linear</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.conv</span> <span class="kn">import</span> <span class="n">Conv2D</span>

<span class="kn">from</span> <span class="nn">pyvqnet.nn</span> <span class="kn">import</span> <span class="n">activation</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.pooling</span> <span class="kn">import</span> <span class="n">MaxPool2D</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim.adam</span> <span class="kn">import</span> <span class="n">Adam</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.linear</span> <span class="kn">import</span> <span class="n">Linear</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">CategoricalCrossEntropy</span>

<span class="kn">from</span> <span class="nn">pyvqnet.tensor.tensor</span> <span class="kn">import</span> <span class="n">QTensor</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">qiskit</span>
<span class="n">simulator</span> <span class="o">=</span> <span class="n">qiskit</span><span class="o">.</span><span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pyvqnet.qnn.utils.qiskitlayer</span> <span class="kn">import</span> <span class="n">QiskitLayer</span>
<span class="kn">from</span> <span class="nn">pyvqnet.data.data</span> <span class="kn">import</span> <span class="n">data_generator</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="k">try</span><span class="p">:</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;TkAgg&#39;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">class</span> <span class="nc">QISKIT_VQC</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class provides a simple interface for interaction</span>
<span class="sd">        with the quantum circuit</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="p">):</span>
                <span class="c1"># --- Circuit definition ---</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span> <span class="o">=</span> <span class="n">qiskit</span><span class="o">.</span><span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)</span>

                <span class="n">all_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">input</span> <span class="o">=</span> <span class="p">[</span><span class="n">qiskit</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">)]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">all_qubits</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_qubits</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
                <span class="c1"># ---------------------------</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shots</span> <span class="o">=</span> <span class="n">shots</span>

        <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>

                <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

                <span class="n">job</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="n">shots</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shots</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

                <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
                <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

                <span class="c1"># Compute probabilities for each state</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">shots</span>
                <span class="c1"># Get state expectation</span>
                <span class="n">expectation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">states</span> <span class="o">*</span> <span class="n">probabilities</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">expectation</span>
</pre></div>
</div>
<p>The next step is to use VQNet to define the model and training process. Use <code class="docutils literal notranslate"><span class="pre">QiskitLayer</span></code> to add the qiskit line to the VQNet model.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define qiskit circuits class</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">QISKIT_VQC</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">simulator</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Net</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">Net</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxpool1</span> <span class="o">=</span> <span class="n">MaxPool2D</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxpool2</span> <span class="o">=</span> <span class="n">MaxPool2D</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hybrid</span> <span class="o">=</span> <span class="n">QiskitLayer</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fc3</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">input_channels</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxpool1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxpool2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">ReLu</span><span class="p">()(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hybrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">x</span>



<span class="k">def</span> <span class="nf">load_mnist</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="s2">&quot;training_data&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;..//..//data//MNIST_data&quot;</span><span class="p">):</span>         <span class="c1"># load data</span>
        <span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">struct</span>
        <span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">pyarray</span>
        <span class="k">if</span> <span class="n">dataset</span> <span class="o">==</span> <span class="s2">&quot;training_data&quot;</span><span class="p">:</span>
                <span class="n">fname_image</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;train-images.idx3-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">fname_label</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;train-labels.idx1-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dataset</span> <span class="o">==</span> <span class="s2">&quot;testing_data&quot;</span><span class="p">:</span>
                <span class="n">fname_image</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;t10k-images.idx3-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">fname_label</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;t10k-labels.idx1-ubyte&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dataset must be &#39;training_data&#39; or &#39;testing_data&#39;&quot;</span><span class="p">)</span>

        <span class="n">flbl</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_label</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">magic_nr</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;II&quot;</span><span class="p">,</span> <span class="n">flbl</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
        <span class="n">lbl</span> <span class="o">=</span> <span class="n">pyarray</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">flbl</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="n">flbl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">fimg</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_image</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">magic_nr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;IIII&quot;</span><span class="p">,</span> <span class="n">fimg</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">pyarray</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">fimg</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="n">fimg</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">lbl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="n">digits</span><span class="p">]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">:</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lbl</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">def</span> <span class="nf">data_select</span><span class="p">(</span><span class="n">train_num</span><span class="p">,</span> <span class="n">test_num</span><span class="p">):</span>
        <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;training_data&quot;</span><span class="p">)</span>  <span class="c1"># load train data</span>
        <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">load_mnist</span><span class="p">(</span><span class="s2">&quot;testing_data&quot;</span><span class="p">)</span>

        <span class="c1"># Train Leaving only labels 0 and 1</span>
        <span class="n">idx_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_train</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">train_num</span><span class="p">],</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_train</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">train_num</span><span class="p">])</span>

        <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span><span class="p">[</span><span class="n">idx_train</span><span class="p">]</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">[</span><span class="n">idx_train</span><span class="p">]</span>
        <span class="n">x_train</span> <span class="o">=</span> <span class="n">x_train</span> <span class="o">/</span> <span class="mi">255</span>
        <span class="n">y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">y_train</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Test Leaving only labels 0 and 1</span>
        <span class="n">idx_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_test</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">test_num</span><span class="p">],</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_test</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">test_num</span><span class="p">])</span>

        <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span><span class="p">[</span><span class="n">idx_test</span><span class="p">]</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test</span><span class="p">[</span><span class="n">idx_test</span><span class="p">]</span>
        <span class="n">x_test</span> <span class="o">=</span> <span class="n">x_test</span> <span class="o">/</span> <span class="mi">255</span>
        <span class="n">y_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">y_test</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
        <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">data_select</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">Net</span><span class="p">()</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
        <span class="n">loss_func</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>

        <span class="n">epochs</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="n">loss_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">start_init</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
                <span class="n">total_loss</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>

                        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
                        <span class="c1"># Forward pass</span>
                        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                        <span class="c1"># Calculating loss</span>
                        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>  <span class="c1"># target output</span>
                        <span class="n">loss_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                        <span class="c1"># Backward pass</span>
                        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
                        <span class="c1"># Optimize the weights</span>
                        <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>
                        <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                        <span class="n">total_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_np</span><span class="p">)</span>

                <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">total_loss</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_loss</span><span class="p">))</span>

                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.0f}</span><span class="s2"> loss is : </span><span class="si">{:.10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">loss_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">end_init</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;run all epochs time </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">end_init</span> <span class="o">-</span> <span class="n">start_init</span><span class="p">)</span><span class="o">.</span><span class="n">seconds</span><span class="p">))</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">loss_list</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;VQNet NN Training&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Training Iterations&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Loss&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


        <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_eval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
                <span class="n">loss_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="n">np_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np_output</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">correct</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
                <span class="n">n_eval</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Eval Accuracy: </span><span class="si">{</span><span class="n">correct</span> <span class="o">/</span> <span class="n">n_eval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="n">n_samples_show</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="n">n_samples_show</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data_generator</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">n_samples_show</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="n">QTensor</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Predicted </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above example is verified in the following qiskit version qiskit: 0.31.0 , qiskit-aer: 0.9.1 , qiskit-aqua: 0.9.5 , qiskit-ibmq-provider: 0.17.0 , qiskit-ignis: 0.6.0 , qiskit-terra: 0.18.3 .</p>
</div>
<p>Loss on training set</p>
<figure class="align-default">
<img alt="../_images/qiskit_hqcnn_train_loss.png" src="../_images/qiskit_hqcnn_train_loss.png" />
</figure>
<p>Run classification on test set</p>
<figure class="align-default">
<img alt="../_images/qiskit_eval_test.png" src="../_images/qiskit_eval_test.png" />
</figure>
</section>
<section id="model-training-using-vqclayer-in-vqnet">
<h3>Model training using VQCLayer in VQNet<a class="headerlink" href="#model-training-using-vqclayer-in-vqnet" title="Permalink to this headline">¶</a></h3>
<p>In the Origin Quantum’s qpanda provides <a class="reference external" href="https://qpanda-tutorial.readthedocs.io/zh/latest/VQC.html#id1">VariationalQuantumCircuit</a> 。
In the circuit, only the doors with variable parameters and constant structure can be composed of VariationalQuantumGate.</p>
<p>VQNet provides the encapsulation class VQC_wrapper, the user uses ordinary logic gates in the
function <cite>build_common_circuits</cite> refers to the sub lines with uncertain line structure in the construction model,</p>
<p>Use vqg in <cite>build_vqc_circuits</cite> construct sub circuits with unchanged structure and variable parameters.
Use the <cite>run</cite> function to define the line operation mode and measurement.</p>
<p>You can refer to the example of model training using VQC <a class="reference external" href="../../../../examples/vqc_wrapper_demo.py">vqc_wrapper_demo</a> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">using pyqpanda VQC api to build model and train VQNet model demo.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span><span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">pyvqnet.nn.module</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">pyvqnet.optim</span> <span class="kn">import</span> <span class="n">sgd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">pyvqnet.nn.loss</span> <span class="kn">import</span> <span class="n">CategoricalCrossEntropy</span>

<span class="kn">from</span> <span class="nn">pyvqnet.tensor.tensor</span> <span class="kn">import</span> <span class="n">QTensor</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">pyvqnet.qnn.quantumlayer</span> <span class="kn">import</span> <span class="n">VQCLayer</span><span class="p">,</span><span class="n">VQC_wrapper</span><span class="p">,</span><span class="n">_array2var</span>
<span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">pyqpanda</span> <span class="k">as</span> <span class="nn">pq</span>

<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">QVC_demo</span><span class="p">(</span><span class="n">VQC_wrapper</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">QVC_demo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">build_common_circuits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">input</span><span class="p">,</span><span class="n">qlists</span><span class="p">,):</span>
        <span class="n">qc</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qlists</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">qc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="n">qlists</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">qc</span>

    <span class="k">def</span> <span class="nf">build_vqc_circuits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">input</span><span class="p">,</span><span class="n">weights</span><span class="p">,</span><span class="n">machine</span><span class="p">,</span><span class="n">qlists</span><span class="p">,</span><span class="n">clists</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">get_cnot</span><span class="p">(</span><span class="n">qubits</span><span class="p">):</span>
            <span class="n">vqc</span> <span class="o">=</span> <span class="n">VariationalQuantumCircuit</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">vqc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">VariationalQuantumGate_CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">vqc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">VariationalQuantumGate_CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">vqc</span>

        <span class="k">def</span> <span class="nf">build_circult</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span><span class="n">vqc</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">Rot</span><span class="p">(</span><span class="n">weights_j</span><span class="p">,</span> <span class="n">qubits</span><span class="p">):</span>
                <span class="n">vqc</span> <span class="o">=</span> <span class="n">VariationalQuantumCircuit</span><span class="p">()</span>

                <span class="n">vqc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">VariationalQuantumGate_RZ</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">weights_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">vqc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">VariationalQuantumGate_RY</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">weights_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">vqc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">VariationalQuantumGate_RZ</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">weights_j</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="k">return</span> <span class="n">vqc</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>

                <span class="n">weights_i</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)):</span>
                    <span class="n">weights_j</span> <span class="o">=</span> <span class="n">weights_i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">vqc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Rot</span><span class="p">(</span><span class="n">weights_j</span><span class="p">,</span><span class="n">qubits</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">cnots</span> <span class="o">=</span> <span class="n">get_cnot</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
                <span class="n">vqc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cnots</span><span class="p">)</span>
            <span class="n">vqc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">VariationalQuantumGate_Z</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>  <span class="c1"># pauli z(0)</span>
            <span class="k">return</span> <span class="n">vqc</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">vqc</span> <span class="o">=</span> <span class="n">VariationalQuantumCircuit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">build_circult</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span><span class="n">qlists</span><span class="p">,</span><span class="n">vqc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vqc</span><span class="p">,</span><span class="nb">input</span><span class="p">,</span><span class="n">machine</span><span class="p">,</span><span class="n">qlists</span><span class="p">,</span><span class="n">clists</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a function to get hamilton observable or measurment</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
        <span class="n">vqc_all</span> <span class="o">=</span> <span class="n">VariationalQuantumCircuit</span><span class="p">()</span>
        <span class="c1"># add encode circuits</span>
        <span class="n">vqc_all</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">build_common_circuits</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">qlists</span><span class="p">))</span>
        <span class="n">vqc_all</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vqc</span><span class="p">)</span>
        <span class="n">qcir</span> <span class="o">=</span> <span class="n">vqc_all</span><span class="o">.</span><span class="n">feed</span><span class="p">()</span>
        <span class="n">prog</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">qcir</span><span class="p">)</span>

        <span class="n">prob</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">prob_run_dict</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qlists</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">prob</span>


<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">qvc_vqc</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qvc</span> <span class="o">=</span> <span class="n">VQCLayer</span><span class="p">(</span><span class="n">qvc_vqc</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qvc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">PATH</span><span class="p">):</span>
    <span class="n">datasets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">PATH</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">label</span>

<span class="k">def</span> <span class="nf">dataloader</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="n">batch_size</span><span class="p">):</span>
            <span class="n">random_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">random_index</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">label</span><span class="p">[</span><span class="n">random_index</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="n">batch_size</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">batch_size</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">batch_size</span><span class="p">],</span> <span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">batch_size</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">get_accuary</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">label</span><span class="p">):</span>
    <span class="n">result</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">score</span>

<span class="k">def</span> <span class="nf">Run</span><span class="p">():</span>
    <span class="c1">### create class for VQC</span>
    <span class="n">qvc_vqc</span> <span class="o">=</span> <span class="n">QVC_demo</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">qvc_vqc</span><span class="p">)</span>

    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">sgd</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span><span class="n">lr</span> <span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">epoch</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">CategoricalCrossEntropy</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start training..............&quot;</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    <span class="n">PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;..//..//data//qvc_data.txt&#39;</span><span class="p">)</span>
    <span class="n">datas</span><span class="p">,</span><span class="n">labels</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">PATH</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epoch</span><span class="p">):</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">sum_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">accuary</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">data</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">(</span><span class="n">datas</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="n">batch_size</span><span class="p">,</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="n">data</span><span class="p">,</span><span class="n">label</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">loss_b</span> <span class="o">=</span> <span class="n">loss</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">result</span><span class="p">)</span>
            <span class="n">loss_b</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>
            <span class="n">sum_loss</span> <span class="o">+=</span> <span class="n">loss_b</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">count</span><span class="o">+=</span><span class="n">batch_size</span>
            <span class="n">accuary</span> <span class="o">+=</span> <span class="n">get_accuary</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;epoch:</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, #### loss:</span><span class="si">{</span><span class="n">sum_loss</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2"> #####accuray:</span><span class="si">{</span><span class="n">accuary</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start testing..............&quot;</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">test_PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;../../data/qvc_data_test.txt&#39;</span><span class="p">)</span>
    <span class="n">test_data</span><span class="p">,</span> <span class="n">test_label</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">test_PATH</span><span class="p">)</span>
    <span class="n">test_batch_size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">accuary</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sum_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">testd</span><span class="p">,</span><span class="n">testl</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">(</span><span class="n">test_data</span><span class="p">,</span><span class="n">test_label</span><span class="p">,</span><span class="n">test_batch_size</span><span class="p">):</span>
        <span class="n">testd</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">testd</span><span class="p">)</span>
        <span class="n">test_result</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">testd</span><span class="p">)</span>
        <span class="n">test_loss</span> <span class="o">=</span> <span class="n">loss</span><span class="p">(</span><span class="n">testl</span><span class="p">,</span><span class="n">test_result</span><span class="p">)</span>
        <span class="n">sum_loss</span> <span class="o">+=</span> <span class="n">test_loss</span>
        <span class="n">count</span><span class="o">+=</span><span class="n">test_batch_size</span>
        <span class="n">accuary</span> <span class="o">+=</span> <span class="n">get_accuary</span><span class="p">(</span><span class="n">test_result</span><span class="p">,</span><span class="n">testl</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;test:---------------&gt;loss:</span><span class="si">{</span><span class="n">sum_loss</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2"> #####accuray:</span><span class="si">{</span><span class="n">accuary</span><span class="o">/</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="n">Run</span><span class="p">()</span>
</pre></div>
</div>
<p>Loss and accuracy results of the run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">start</span> <span class="n">training</span><span class="o">..............</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="c1">#### loss:0.22664549748102825 #####accuray:0.5333333333333333</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="c1">#### loss:0.20315084457397461 #####accuray:0.6666666666666666</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="c1">#### loss:0.1644243836402893 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="c1">#### loss:0.12654326359430948 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="c1">#### loss:0.11026077469189961 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="c1">#### loss:0.10584278305371603 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="c1">#### loss:0.10476383566856384 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="c1">#### loss:0.10450373888015747 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="c1">#### loss:0.10444082617759705 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span> <span class="c1">#### loss:0.10442551374435424 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="c1">#### loss:0.10442176461219788 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span> <span class="c1">#### loss:0.10442084868748983 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="c1">#### loss:0.10442061225573222 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">13</span><span class="p">,</span> <span class="c1">#### loss:0.10442055265108745 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">14</span><span class="p">,</span> <span class="c1">#### loss:0.10442055265108745 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">15</span><span class="p">,</span> <span class="c1">#### loss:0.10442055265108745 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span> <span class="c1">#### loss:0.10442055265108745 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="c1">#### loss:0.10442055265108745 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">18</span><span class="p">,</span> <span class="c1">#### loss:0.10442055265108745 #####accuray:1.0</span>
<span class="n">epoch</span><span class="p">:</span><span class="mi">19</span><span class="p">,</span> <span class="c1">#### loss:0.10442055265108745 #####accuray:1.0</span>
<span class="n">start</span> <span class="n">testing</span><span class="o">..............</span>
<span class="p">[</span><span class="mf">0.3132616580</span><span class="p">]</span>
<span class="n">test</span><span class="p">:</span><span class="o">---------------&gt;</span><span class="n">loss</span><span class="p">:</span><span class="n">QTensor</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#####accuray:1.0</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="install.html" class="btn btn-neutral float-left" title="Steps of VQNet Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="QTensor.html" class="btn btn-neutral float-right" title="QTensor Module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Original Quantum.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>